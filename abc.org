#+TITLE:A journey of a thousand miles begins with a single step
* perl
** Learning perl
*** 标量数据
chr()将代码点转化为字符
 ord()把字符转换为代码点
 单引号内所有字符都代表它们自己（除单引号和反斜线）
 最好习惯加上use utf8;
 字符串可以用.连接起来，
 字符串重复操作符x
 行输入操作符：<STDIN>
 chomp() 去掉末尾换行符
   chomp($text = <STDIN>)
*** 列表和数组
**** 零散
 “负数数组索引值”索引值不能超过数组大小，数组中有3个元素，则有效负数索引值为-1(最后一个元素）
 列表：（"fred","fred2"）<> qw(fred fred2)
 @符号引用整个数组
 unshift、shift对数组的开头进行处理
 push、pop对数组的结尾进行处理
 push(@array, (3, 4, 5));
 splice @array, 2, 1, qw(wilma)#目标数组，开始位置，操作元素长度，要替换的列表
 reverse返回次序相反的列表，

my @list = () ;
if(@list){
    print "Not empty!\n" ;
}

**** split用法
$info="Caine:Michael:Actor:14,LeafyDrive";
@personal=split(/:/,$info);
其结果是：@personal=("Caine","Michael","Actor","14,LeafyDrive");
**** foreach用法
 @rocks = qw/ bedrock slate lava /;
 foreach $rock (@rocks){
    $rock = "\t$rock";
 }
 print @rocks;
 @rocks的值在循环过程中被修改，控制变量$rock的值不变

 foreach (1..10){   #默认会用$_作为控制变量
   print "$_"
 }
**** each用法
 my @rocks = qw/ bedrock slate /;
 while ( my $index, $value) = each @rocks{
 say "$index":"$value";
 }
**** 标量上下文与列表上下文
 在Perl中，表达式总是根据所需要的上下文返回对应的值。
 以数组的“名称”为例：在列表上下文中，它会返回元素的列表，在标量上下文中， 则返回数组中的元素个数
 @people = qw( fred barney betty );
 @sorted = sort @people; # 列表上下文
 $number = 42 + @people; # 标量上下文：42+3 = 45

 @betty = () 清空数组

scalar @rocks 强制指定标量上下文，

<STDIN>在标量上下文中会返回输入数据的下一行；在列表上下文中返回所有剩下的行，知道文件结尾
Unix或类似系统，键入C+D表示结束，DOS/Windows用C+Z
chomp(@lines = <STDIN>);#读入所有行，换行符除外，
*** 子程序
**** 定义
sub marine{}
**** 调用
&marine;
**** 返回值
最后执行的表达式的结果，
**** 参数
$n = &max(10,15); #第一个参数存储于$_[0],第二个$_[1];
sub max{
  if($_[0]>$_[1]){
    $_[0];
  }else{
    $_[1];
  }
}

@_是子程序的私有变量，即使递归调用自己，每次调用仍然是一个新的@_,@_包含它的参数列表
**** 子程序中的私有变量
sub max{
  my($m,$n) = @_;
  if($m>$n){$m}else{$n};
}

**** 变长参数列表
$maximum = &max(3,5,6);
sub max{
  my($max_so_far) = shift @_;
  foreach(@_){
    if($_>$max_so_far){
      $max_so_far = $_;
    }
  }
  $max_so_far;
}
**** 关于词法（my）变量
my操作符不会更改变量赋值时的上下文
my($num) = @_; #列表上下文，和($num) = @_；相同，$num被设为第一个参数；

my操作符不加括号时，只能用来声明单个词法变量
my $fred,$barney; #只声明了一个
my ($fred, $barney);#声明了两个

my可以用来创建新的私有数组 my @phone_number;
所有新变量的值一开始都是空的：标量被设为undef,数组被设为空列表
**** 持久性私有变量
state $ = 0;
*** 输入输出
**** 来自钻石操作符的输入
钻石操作符是行输入操作符的特例，不是从键盘取得输入，而是从用户指定位置，
while(defined($line = <>)){
  chomp($line);
  print "It was $_ that I saw\n";
}

while(<>){
  chomp;
  print "It was $_ that I saw\n";
}
**** 调用参数
 从技术上来看，钻石操作符不回去检查命令行参数，它的参数来自@ARGV数组，
 这个数组是由perl解释器事先建立的特殊数组，其内容就是由命令行参数组成的列表，
 钻石操作符会查看数组@ARGV，然后决定用哪些文件名，
 这表示程序开始之后，只要尚未使用钻石操作符，你就可以处理@ARGV,
@ARGV = qw# larry curly#;
while(<>){
  chomp;
}
**** 打开文件句柄
 open (my $fh,'>:utf8','test.java');
'<'：只读
'>'：创建新文件
'>>'：追加，

一次性读取整个文件
#打开文件
open(my $fh,"<:encoding(UTF-8)",$files[0])||die"cannot open the file: $!\n";

local $/=undef;
my $linelist=<$fh>;

程序中把分隔符$/设置为未定义，分隔符$/默认情况下是等于回车的
**** 用die处理错误
die "cannot create:$!"
$！系统错误信息
**** 自动检测致命错误
use autodie;//如果open失败，自动启动die;
**** 用say输出
自动加换行
*** 哈希
**** 哈希的健与值
哈希的键与值都是任意标量，但键总是被转换成字符串，
键总是唯一的，值可以是重复的数字、字符串、undef
**** 访问哈希
$hash{$key}
**** 访问整个hash
%some_hash = ('foo',35,'bar',12,2.5,'hello');
@any_array = %some_hash;//展开hash，将它变成键值列表，无序
**** 哈希赋值
my %new_hash = %old_hash;
my %inverse_hash = reverse %any_hash;(key,value)->(value, key);
**** 胖箭头
my %last_name = (key => value,)//键可以省略引号
**** 哈希函数
my @k = keys %hash;
my @v = values %hash;
**** each函数
while (($key, $value)=each %hash){
 print "$key => $value";
}
**** exists函数
exists $books{"dino"};
**** delete函数
delete $books{$person}
*** 正则表达式
**** 元字符
.通配符(换行符除外\n)
\.匹配.本身
**** 量词
*零次或多次
+一次以上
？出现一次或不出现
**** 模式分组
/(fred)+/会匹配fredfred这样的字符串
/(.)(.)\2\1/ 匹配'abba'
**** \g{N}
$_ = "aa11bb";
if(/(.)\g{-1}11/)
**** 择一匹配
(|)或
**** 字符集
字符集指的是可能出现的字符，通过写在([])内表示
只能匹配单个字符，但可以是字符集中的任何一个
如[a b c]可以匹配三个字符中的任一个，
[a-zA-Z]

可以在字符集开头加上(^)脱字符，表示除这些字符以外，
[^n\-z]这里的连字符要加上反斜线，
**** 字符集的简写
/[\d]/a #a表示按老的ASCII字符语义解释
\s匹配任意空白符
\R匹配断行符
\w在ASCII语义下匹配[a-zA-Z0-9_]
**** 反义简写
\D,\S\W
*** 用正则进行匹配
**** 用m//进行匹配
/fred/是m//(pattern match operator)的简写，m(fred)
**** 模式匹配修饰符
用/i进行大小写无关匹配
用/s匹配任意字符(.无法匹配换行符)
用/x加入空白符
#号是注释的标记，[#]#本身
**** 结合选项修饰符
/braney.*fred/is用时使用/i 和/s
**** 选择一种字符解释方式
共有三种字符解释方式：ASCII、Unicode和locale(/a,/u,/l)
**** 锚位
\A锚位匹配字符串的绝对开头，
m{\Ahttps?://}i #是否以https开头

\z匹配字符串的绝对末尾
m{\.png\z}i

\Z锚位后面不允许出现换行符
**** 单词锚位
\b是单词边界锚位，它匹配任何单词的首尾
/\bfred\b/匹配fred，不匹配frederick

非单词锚位是\B
/\bsearch\B/会匹配serches，但不匹配search或researching
**** 绑定操作符=~
默认情况下模式匹配的操作对象是$_,
绑定操作符=~告诉perl，用右边的模式来匹配左边的字符串
$some_other =~ /\brub/
<STDIN> =~ /\byes\b/i;
**** 模式中的内插
my $what = "larry"
(/\A($what)/
**** 捕获变量
$_ = "hello there, neighbor";
if(/(\S+) (\S+ )/{
 print "the word was $1 $2\n";
}

my $test = "int(11)"1;
if($test =~ /(\d+)/){
    print $1;
}

my $string=qq(<dependency org="org.springframework" name="spring" rev="2.5.4" conf="zip->default" />);
my @matched= ( $string =~ /\"([^\"]+?)\"/g);
print "@matched";

**** 不捕获模式
/(?:bronto)?saurus (steak|burger)/使用不捕获圆括号跳过"bronto"
**** 命名捕获
my $names = 'fred or barney';
if($names =~ m/(?<name1>\w+) (?<name2>\w+)/){
  say "I saw $+{name1} and $+{name2}";
}
使用捕获标签之后，之前我们用\1或\g{1}可以改用\g{lable}
也可以用另一种语法表示反向引用， \k<label>等效于\g{lable};
**** 自动捕获变量
$&、$`和$'
$& 实际匹配模式部分
$` 匹配区段之前部分
$' 从未匹配到的部分

修饰符/p值针对特定的正则表达式开启自动捕获变量
${^PREMATCH} 、${^MATCH}和{^POSTMATCH}
**** 通用量词
/a{5,15}/ 匹配重复出现的5到15次的字母a
/a{3,}/ 匹配次数没有上限
/a{8}/ 固定次数
**** 优先级
| 正则表示式特性       | 示例                     |
| 圆括号（分组或捕获） | (..),(?:..),(?<label>..) |
| 量词                 | a*,a+,a?,a{n,m}          |
| 锚位和序列           | abc,^,$,\A,\b,\z,\Z      |
| 择一竖线             | 竖线                     |
| 原子                 | a,[abc],\d,\1,\g{2}      |
**** 积累
***** 匹配换行符，取第几行
(split(/[\n]/s,$test))[1];
*** 用正则表达式处理文本
**** 用s///进行替换
s/barney/fred/; #把barney替换成 Fred
s///返回的是布尔值，
**** 用/g进行全局替换
s///只会进行一次替换
/g修饰符可让s///进行所有替换
s/home/cave/g;

s/\s+/ /g; #缩减空白
s/^\s+|\s+$//g; #去除开头和结尾的空白符
**** 可用替换修饰符
除/g外还可以使用/i,/x以及/s
**** 绑定操作符 =~
$file_name =~ s/^.*/s;
**** 无损替换 /r
my $copy = $orginal =~ s/\d+ ribs、10 ribrs/r;
**** 大小写替换
\U 所有字符转换成大写
\L 所有字符转换成小写
默认影响之后全部字符串，用\E关闭大小写转换
使用\u,\l时，只会影响紧跟其后的第一个字符
同时使用\u,\L表示首字母大写，后面小写
\LORGAGA\ED\LGADFADAD";
**** join函数
my $x = join "："，4,5,6 #$x为 "4:5:6";

**** 非贪婪量词
+ 非贪婪量词 +?(一次或多次，匹配的字符串越短越好，)
? 非贪婪量词 ??
**** 一次更新多个文件
要在perl中直接修改文件内容可以使用钻石操作符(<>)
$^I = "~";#该字符串会变成备份文件的扩展名
while(<>) {
  s/^Author:.*/Author:Randal L. Schwartz/;
  print;
}
**** 从命令行直接编辑
如果你需要更新上百个文件，把里面拼错的Randall改成Randal
$ perl -p -i.bak -w -e 's/Randall/Randal/g' fred*.bat
-p选项可以让Perl自动生成一小段程序，类似如下片段
while(<>){
  print;
}
-i.bak 作用就是在程序开始之前把$^I设为".bak"
如果不需要备份直接用 -i
-w 开启警告功能
-e告诉Perl后面是可执行程序代码
fred*.dat表示@ARGV的值应该是匹配此文件名模式的所有文件名

*** 其他控制结构
**** unless
 条件为假时执行
**** until
颠倒while循环条件，条件为真时停止执行，
**** 表达式修饰符
print "hello" if $n <0;
$i*=2 until $i>$j
左边不能放多条语句
**** 裸块控制结构{}
只执行一次，
**** elsif子句
if(){}elsif{}else{}
**** 循环控制操作(for、foreach、while、until、裸块)控制符(last,next,redo)
last 循环中止符
next 结束当前这次循环，跳到当前循环块的底部，
redo 将控制返回到当前循环的顶端，而不经过任何条件测试，也不会进入下一次循环迭代
**** 带标签的块(从内层对外层的循环块进行控制label)
标签大写,靠左，标签应该用来命名整块代码，而不是表面具体位置，
外层循环命名：LINE,内层WORD;
LINE:while(<>){
  foreach(split){
    last LINE if /_END_/;
  }
}
**** 条件操作符?:
**** 逻辑操作符：&&,||
**** 定义或(defined-or) 操作符：//
左边的值属于已定义时进行短路操作，而不管该值属于逻辑真还是逻辑假，
**** 使用部分求值操作符(&&,||,//,?:)的控制结构
($m < $n)&& ($m = $n);<==> $m = $n if $m<$n;
($m < $n)?($m=$x):($n=$x);(将$x赋给较小的变量)
open my $fh, '<', $filename or die "cannot open"
*** perl模块
**** 寻找模块
检查文档是否安装过：perldoc CGI
列出已安装模块 cpan -a
**** 安装模块
***** PPM方式
1，安装ActivePerl（内附PPM）；
2,装好库,这些网站都有编译好了的模块；
3,用命令安装,ppm install 模块名称
添加库的方法:在cmd中运行命令ppm repo suggest(意思是给出建议添加的网站),
然后将列出的网站使用命令 ppm repo add ***(网站名)添加,全部添加完
ppm repo add  activestate
ppm install Math::MatrixReal
***** 手动编译方式
编译步骤,在cpan上下载需要的模块
perl Makefile.pl
dmake
dmake test
dmake install
***** 使用CPAN模块自动安装
perl　-MCPAN　-e　shell　
install　Math::MatrixReal
perl -MCPAN -e "install DBD::mysql"
***** 使用cpanm
cpanm DBI WWW::Mechanize
**** 安装到自己的目录
使用local::lib模块可以安装模块到用户目录下，
perl -Mlocal::lib列出所改动的所有环境变量设定
**** 仅选用模块中的部分函数
use File::Basename qw/ basename /;
use File::Basename ();
my $betty = File::Basename::dirname $name;
*** 文件测试
**** 文件测试操作符
-e 检查文件是否已经存在 if -e $filename
-S 检查文件大小
**** 测试同一文件的多项属性
if(-r $file and -w_){}
**** 栈式文件测试操作符
if(-w -r $file){..}
靠近文件名的测试会先被执行，次序为从右向左，
**** stat和lstat函数
stat返回丰富的文件信息，
若需要符号链接本身的信息，可以用lstat
**** localtime函数
**** 按位运算操作符
**** 使用位字符串

*** 目录操作
**** 在目录中移动
chdir '/etc';
**** 文件名通配
glob 文件名通配符，
my @all_files = glob '*';
@all_files取得目录中所有文件但不包括以点号开头的文件
my @pm_files = glib '.* *.pm';#参数中用空格匹配多个模式
**** 文件名通配的另一种语法
my @dir_files = <$dir/* $dir/.*> #文件名通配操作
my @lines = <FRED> #从文件句柄读取
my @files = <FRED/*> #文件名通配操作
如果尖括号内满足Perl标识符条件的，就作为文件句柄来读取，否则就是文件名通配操作，
**** 目录句柄
my $dirname = '../order';
opendir my $dh, $dirname or die "error";
foreach my $file (readdir $dh){
  next if $file =~ /^\./; #跳过名称以点号开头的文件
  next unless -f $file and -r $file; #只需要可读的文件
  print "one file in $dirname is $file\n";
}
closedir $dh;
也可以选裸字作为目录句柄的名称
目录句柄的读取比文件名通配提供更佳的性能，
目录句柄返回的名称并未按照任何特定的顺序排列，
只处理已pm结尾的文件：
while ($name = readdir $dh){
  next unless $name =~ /\.pm$/;
}
取得所有名称不以点号开头的文件: next if $name=~ /^\./;
如果要排除.(当前目录)和..(上层目录)，可以直接写明：next if $name eq '.' or name eq '..';
readdir返回的文件名不包含路径名，加上路径名称才能得到全名($dirname/$name);
可以用File::Spec::Functions构造适用于本地系统的文件名
use File::Spec::Functions;
$name = catfile($dirname,$name) #拼合为完整的路径
**** 递归访问目录
File::Find 可以完成目录递归处理
对于更为复杂的任务，可以使用File::Find::Rule和File::Finder
**** 删除文件(unlink)
unlink 'slate','bed'
unlink qw(slate bed);
unlink glob '*.o'
**** 重命名文件(rename)
rename 'old','new';
可以将文件移到其他目录
rename 'over_there/some_file','some_file';
批量把名称以.old结尾的文件改名为.new
foreach my $file(glob "*.old"){
  my $newfile = $file;
  $newfile =~ s/\.old$/.new/;
}
if(-e $newfile){
  warn "";
}elsif(rename $file => $newfile){};
在Perl 5.14里借助/r标志，可以直接在s///替换时生成新的文件名
my $newfile = $file =~ s/\.old$/.new/r
**** 链接与文件
link 'chicken', 'egg'
readlink取得符号链接指向的位置，
这两种链接都可以通过unlink移除
**** 创建和删除目录
mddir 'fred',0755 or warn"";
0755 八进制数值，呗解释成3位一组的Unix权限值，赋予你完整的权限，其他人只能读取
oct() 可以强制把字符串当成八进制数字处理

rmdir 移空目录，每次只能删除一个目录
如果对非空目录调用rmdir函数会导致失败，
File::Path里面的rmtree提供了比较完整的解决方案。
**** 修改隶属关系(chown)
my $user = 1004;
my $group = 100;
chown $user, $group, glob '*.o';
getpwnam函数可以讲用户名转换成用户编号，
**** 修改时间戳(utime)
my $now = time;
my $ago = $now -24*60*60;
utime $now, $ago, glob '*';
*** 字符串与排序
**** index查找子字符串
$where = index($big, $small);#返回第一个字符匹配位置，
第三个可选参数指定开始位置，
rindex会从字符串尾部开始找起。
**** 用substr操作子字符串
my $part = substr($string, $initial_position, $length);
省略第三个参数，就一直取到字符串结尾，
起始位置可以为负值，表示从字符串结尾开始倒数，
my $string = "hello, world";
substr($string,0,5)= "Goodbye";#$string 现在的值为"Goodbye, world";
substr($tring,-20)=~s/fred/barney/g;
substr和index通常比正则表达式稍快，没有正则表示式引擎的额外负担，；
他们总是区分大小写，不会动用任何内存变量，
substr第四个参数是替换子字符串，
**** 用sprintf格式化字符串
可以将格式化后的字符串存放在变量里，不会直接打印出来
my $money = sprintf "%.2f", 2.499;
格式化金额，使用逗号分隔
sub big_money{
 my $number = sprintf "%.2f", shift @_;
 #下面这个循环中，每匹配到的合适位置加一个逗号
 1 while $number =~ s/^(-?\d+)(\d\d\d)/$1,$2/;
 #在正确的位置补上美元符号
 $number =~s/^(-?)/$1\$/;
 $number;
}
**** 高级排序
***** 排序子程序
$a与$b被自动赋值好，是两个来自原始列表的元素
sub by_number{
  if($a<$b){-1}
  elsif($a>$b){1}
  else{0}
}
my @result = sort by_number @some_number;

<=>数字比较符 会返回三种比较结果
sub by_number($a <=> $b) #按数字排序
my @number = sort {$a <=> @some_number} #简单写法
my @descending = sort{$b <=> $a} @some_number; #倒序排列

cmp字符串操作符，返回三种比较结果
sub by_code_point{$a cmp $b}

cmp可以用来建立复杂的排序顺序
sub case_insensitive{ "\L$a" cmp "\L$b"}#不区分大小写

对Unicode字符串排序
use Unicode::Normalize;
sub equivalents {NFKD($a) cmp NKFD($b)}
***** 按哈希值排序
my %scroe = ("barbey" => 195, "fred" => 205);
my @winners = sort by_score key %scroe;
sub by_score { $score{$b} <=> $score{a}}; #按积分降序排列
***** 按多个键排序
sub by_score_and_name {
 $score{$b} <=> $score{$a}
  or
 $a cmp $b  #分数相同按名字排序
}

*** 字符串操作函数
**** 1，index
position = index (string, substring, position)
返回子串substring在字符串string中的位置，如果不存在则返回-1。参数position是可选项，表示匹配之前跳过的字符数，或者说从该位置开始匹配。

例：
[root@localhost ~]# echo -n '/var/fap/test/123' | perl -ne '$rev=index($_, "a"); print $rev,"\n";'
2

**** 2，rindex
position = rindex (string, substring, position)
与index类似，区别是从右端匹配。

例：

[root@localhost ~]# echo -n '/var/ftp/tesa/123' | perl -ne '$rev=rindex($_, "a", 11); print $rev,"\n";'
2
**** 3，length
num = length (string)
返回字符串长度，或者说含有字符的数目。
**** 4，substr
substr (expr, skipchars, length)
抽取字符串（或表达式生成的字符串）expr中的子串，跳过skipchars个字符，
或者说从位置skipchars开始抽取子串（第一个字符位置为0），子串长度为length，

此参数可忽略，意味着取剩下的全部字符。
当此函数出现在等式左边时，expr必须为变量或数组元素，此时其中部分子串被等式右边的值替换。

substr() 函数的作用有两个：替换一部分子串。 删除一部分子串。

例：

[root@localhost ~]# echo -n '/var/ftp/test/123' | perl -ne '$rev=substr($_, 9,);print $rev,"\n";'
test/123
[root@localhost ~]# echo -n '/var/ftp/test/123' | perl -ne '$rev=substr($_, 9, 4);print $rev,"\n";'
test

替换：
[root@localhost ~]# echo -n '/var/ftp/test/123' | perl -ne '$rev=substr($_, 9, 4)="hello"; print $rev,"\n";'
hello
删除：
[root@localhost ~]# echo -n '/var/ftp/test/123' | perl -ne '$rev=substr($_, 9, 4)=""; print $rev,"\n";'

**** 5，lc，uc，lcfirst，ucfirst
lc，将字符串改为小写
uc，将字符串改为大写
lcfirst，改变字符串首字母小写
ucfirst，改变字符串首字母大写

例子如下：

[root@localhost ~]# echo -n 'hello, hanli' | perl -ne '$rev=uc($_); print $rev,"\n";'
HELLO, HANLI
[root@localhost ~]# echo -n 'HELLO, hanli' | perl -ne '$rev=lc($_); print $rev,"\n";'
hello, hanli
[root@localhost ~]# echo -n 'hello, Hanli' | perl -ne '$rev=ucfirst($_); print $rev,"\n";'
Hello, Hanli
[root@localhost ~]# echo -n 'hello, Hanli' | perl -ne '$rev=lcfirst($_); print $rev,"\n";'
hello, Hanli

**** 6，pos
offset=pos(string);
返回最后一次模式匹配的位置。
**** 7，quotameta
newstring=quotemeta(oldstring);

将非单词的字母前面加上反斜线(\)。

语句：$string=quotemeta($string);
等效于：$string=~s/(\W)/\\$1/g;

常用于模式匹配操作中，确保字符串中没有字符被看作匹配操作符。

**** 8，join
join(joinstr,list);

把字符串列表(数组)组合成一个长的字符串，在每两个列表元素间插入串joinstr。

**** 9，sprintf

调用语法sprintf(string,fields);

与printf类似，区别是结果不输出到文件，而作为返回值赋给变量。

例子$num=26;

$outstr=sprintf("%d=%xhexadecimalor%ooctal\n",$num,$num,$num);

print($outstr);

结果输出26=1ahexadecimalor32octal
*** 智能匹配与given-when结构
**** 智能匹配操作符 ~~
用于判断是否相同，比较大小不能用智能匹配符
~~会根据两边的操作数的数据类型自动判断该用何种方式进行比较或匹配
$name ~~ /Fred/ #执行模式匹配操作
%names ~~ /Fred/ #遍历%names的所有键，用给定的正则表达式逐个测试，找到返回真
@name1 ~~ @name2 #比较两个数组是否完全相同
**** 智能匹配操作的优先级
perlsyn文档中的"Smart matching in detail"

智能匹配操作符对不同操作数的处理
| 范例                         | 匹配类型                           |
| %a ~~ %b                     | 哈希的键是否一致           |
| %a ~~ @b或 @a ~~ %b          | %中的至少一个键在列表@b中          |
| %a ~~ /Fred/ 或 /Fred/ ~~ %a | 至少一个键匹配给定的模式           |
| 'fred'~~ %a                  | 是否存在$a{fred}                   |
| @a ~~ @b                     | 数组是否相同                       |
| @a ~~ /Fred/                 | @a中至少有一个元素匹配模式         |
| $name ~~ undef $name         | $name没有定义                      |
| $name ~~ /Fred/              | 模式匹配                           |
| 123 ~~ ‘123.0’             | 数值和"numish"类型的字符串是否相等 |
| 'fred' ~~ 'fred'             | 字符串是否相等                     |
| 123 ~~ 234                   | 数值是否相等                       |
**** given语句
given ($ARGV[0]){
  when ('Fred') {say 'Name is Fred';break}
  when (/Fred/i) {say 'name has Fred;continue}
  when (/AFred/) {say 'name starts with Fred'}
  default {say 'I don't see a Fred';}
}
默认加上break，现在就跳出given-when结构
continue继续执行后续的when，
倒数第二个不能加continue;
given-when使用了智能匹配
**** 笨拙匹配
在特定情况下perl会自动使用笨拙匹配，在when里调用某个子程序，在内置函数函数中，
否定的表达式，包括否定的正则表达式，都不会使用智能匹配
when( ! /Fred/i) #笨拙匹配
**** 多个条目的when匹配
要遍历多个元素，可以直接省略given，让foreach将当前正在遍历的元素放入自己的$_里
foreach (@name){#不要使用具名变量
  say "\nProcessing $_";
  when( /Fred/) {say... }
  when( /\AFred) {say..}
  say "Moving";
  default {}

}
*** 进程管理
**** system函数
启动子进程用system函数，
从perl调用Unix的date命令:system 'date';

**** 避免使用shell
system操作符也可以用一个以上的参数来调用，这样就不会用到shell
my $tarfile = 'something*wicked.tar';
my $@dirs = qw(fred|flintstone <barney&rubble> betty);
system 'tar', 'cvf', $tarfile, @dirs;
tar 是命令名称，得到5个参数，包括一个选项，一个打包后的文件名称，已经三个要打包的文件
**** 环境变量
在Perl中，环境变可通过%ENV哈希获得，
程序开始运行时，%ENV会保留父进程继承而来的设定值，修改此哈希能改变环境变量，
$ENV{'PATH'} = "/home/bin:$ENV{'PATH'}";
my $make_result = system 'make';
**** exec函数
system会创建子进程，而exec函数却导致perl进程自己去执行任务，
例如要运行/tmp下的bedrock命令并带上-o argsl以及程序本身所调用的参数：
chdir '/tmp' or die "Cannot chdir /tmp:$!";
exec 'bedrock', '-o', 'args1',@ARGV;
运行exec时，perl找到bedrock并跳进去执行，就没有perl进程了，
当bedrock运行结束时，就没有perl进程在等待，
这个程序perl的主要功能是为另一个程序的运行设置运行环境
可以预先修改环境变量，修改当前工作目录，修改默认的文件句柄。
**** 用反引号捕获输出结果
无论用system还是exec，所有执行命令的输出都会送到Perl的标准输出，
要提取该信息，只要用反引号代替''、""就可以
my $now = `date`;#捕获date命令的输出

要取得一系列perl函数的说明文档，可以重复执行perldoc命令，每次使用不同的参数
my @functions = qw{ int rand sleep length};
my %about;
foreach (@functions){
    $about{$_} = `perldoc -t -f $_`; #可以用qx()代替``;
}
print %about;

要执行的命令本身就需要反引号，可以用qx()代替，
选用单引号作为分隔符，可以禁止变量内插，
**** 在列表上下文中使用反引号
如果命令会输出很多行，在标量上下文中``会得到一个很长的字符串包括换行符，
在列表上下文中，则会输出按行拆分的列表
my @who_lines = `who`;
**** 用IPC::System::Simple执行外部进程
可以直接用它提供的同名函数取代内置的system函数，但更为强大
还提供了systemx函数，在执行外部命令时不会通过shell调用，
如果要捕获外部命令输出，只要把system或systemx改为capture或capturex就行
my @output = capturex 'tar', 'cvf', $tarfile, @dirs;
**** 通过文件句柄执行外部进程
到目前为止我们看到的方法都是由perl同步控制子进程，启动命令，等待结束
但perl可以启动一个异步运行的子进程，并和它保持通信，知道子进程结束
**** 用fork进行深入和复杂的工作
想要深入的话，参阅perlioc文档，
**** 发送及接收信号
*** 高级Perl技巧
**** 切片
my $(undef, $card_num) #含有undef，忽略源列表的相应元素
列表切片：perl可以把列表当做数组，用索引取得里面的值，
my $card_num = (split /:/)[1];
my $count = (split /:/)[5];
my ($card_num, $count) = (split /:/)[1,5];

切片常常是从列表中读取少量数据的最简单方法，
my($first, $last) = (sort @names)[0,-1] #-1代表最后一个元素
切片的下标可以是任意顺序的，也可以重复
**** 数组切片
从数组（而不是列表）切出元素时，圆括号不是必须的，
my @number = @names[9,0,2];
在perl里，$意味着一个东西，@意味着一组东西，%代表一整个哈希

切片可以直接内插到字符串里去：
print "Bedrock @names[9,3,2]\n";

@items[2,3] = ($address, $home); #修改数组中的元素
相当于赋值给($item[2],$item[3]),但更简洁高效
**** 哈希切片
my @three_scores = ($scroe{"barney"}, $score{"fred"});
my @three_scores = @scores{ qw/ barney fred/};
切片一定是列表，因此哈希切片也是用@符号来表示，类似@scroe{..},花括号意味着要检索的哈希成员
如果前置$,下标表达式会返回单一键值，
如果前置@，返回一个键值列表
%代表整个hash，所以用@；

下面的程序将选手的分数存入哈希
my @players = qw/ barney fred/
my @bowling_scores = (195,190);
@scores(@players)=@bowling_scroes;

哈希切片也可以被内插进字符串
print "players are : @players";
print "Their scors were: @scores{@players}";
**** 捕获错误
**** 用eval
用eval捕获错误
my $barney = eval {$fred /$dino};
eval的返回值是语句块最后一条表达式的执行结果，
捕获到错误，eval会返回undef在特殊变量$@中设置错误消息;
在列表上下文中，捕获到错误eval会返回空列表，
eval{} if($@){}
4种类型的错误eval无法捕获
 1.语法错误，（eval仅能捕获运行时错误）
 2.让perl解释器本身崩溃的错误，比如内存溢出或者收到无法接管的信号，
 3.警告，
 4.exit操作符会立即终止程序运行，
**** 更为高级的错误处理
用die抛出异常，用eval捕获异常，通过$@判断发生了什么错误
{
 eval{
   die "" if $unexpected;
 }
 if($@=~/unexpected/){}
}

Try::Tiny模块可以解决die,eval的不足
use Try::Tiny;
try{}
catch{}
finally{}
**** autodie
autodie,自动抛出异常
use autodie qw( open system :socket);
use Try::Tiny;
try{
 open my $fh,'>',$filename;
}catch{
 when ('open'){say 'cannot opne'};
}
**** 用grep筛选列表
my @odd_numbers = grep { $_ % 2} 1..1000 #筛选出500个奇数
grep {代码块} 被筛选的元素列表
my @matching_lines = grep {/\bfred\b/i} <$fh>; #从一个文件中取出包含fred的行
my @matching_lines = grep /\bfred\b/i, <$fh>;  #逗号表示表达式结束

grep在标量上下文中返回符合条件的元素个数
**** 用map把列表元素变形
my @formatted_data = map {&big_money($_)} @data;
参数：一个使用$_的代码块和一个待处理的列表
将$_设成列表每个元素的别名，逐个执行代码，
map使用代码块中最后一个表达式的方式和grep不同，它返回的不是逻辑真价值，而是表达式的实际计算结果，
最终返回结果组成的列表。map表达式是在列表上下文中求值的，
打印金额数字：map {sprintf("%25s\n", &big_money($_))} @data;
**** 更花哨的列表工具
List::Util模块包含在标准库中，提供常见高效的列表处理工具，
use List::Util qw(first);
my $first_match = first{/\bPebbles\b/i} @characters;

use List::Util qw(sum);
my $total = sum(1..1000); #得到总和500500；

找最大值：
my $max = max（3,5，10）; #maxstr处理字符串

随机排序： shuffle()

List::MoreUtils提供更多的工具
use List::MoreUtils qw(none any all)

if(none {$_>100} @number){}
elsif(any {$_>50} @number){}

要合并多个列表，可以使用mesh构造一个大型列表，交错填充原始列表，
my @large_array = mesh @abc,@number,@dions;
** Intermediate perl
*** Using Modules
**** Functional Interfaces
my $basename = basename( $some_full_path );
use File::Basename (); # no import
my $base = File::Basename::basename($some_path);
**** Object-Oriented Interfaces
use File::Spec;
my $filespec = File::Spec->catfile( $homedir{gilligan},'web_docs', 'photos', 'USS_Minnow.gif' );
**** Spreadsheet::WriteExcel
#+BEGIN_EXAMPLE perl
use Spreadsheet::WriteExcel;
# Create a new Excel workbook
my $workbook = Spreadsheet::WriteExcel->new('perl.xls');
# Add a worksheet
my $worksheet = $workbook->add_worksheet();
# in Excel's A1 cell
$worksheet->write( 0, 0, 'Hello Excel' );

# making our worksheet look a little prettier
my $red_background = $workbook->add_format(
color => 'white',
bg_color => 'red',
bold => 1,
);
my $bold = $workbook?>add_format(
bold => 1,
);

# use format
$worksheet->write( 0, 0, 'Colored cell', $red_background );
$worksheet->write( 0, 1, 'bold cell', $bold );

# tell Excel that it is a string by using write_string
my $product_code = '01234';
$worksheet->write_string( 0, 2, $product_code );

# create formulas
$worksheet->write( 'A2', 37 );
$worksheet->write( 'B2', 42 );
$worksheet->write( 'C2', '= A2 + B2');
#+END_EXAMPLE
*** Intermediate Foundations
**** List Filtering with grep
*the expression form*
my @results = grep EXPR, @input_list;
my $count = grep EXPR, @input_list;

EXPR stands in for any scalar expression that should refer to $_ (explicitly or implicitly)
my @input_numbers = (1, 2, 4, 8, 16, 32, 64);
my @bigger_than_10 = grep $_ > 10, @input_numbers;
my @end_in_4 = grep /4$/, @input_numbers;

my @odd_digit_sum = grep digit_sum_is_odd($_), @input_numbers;
sub digit_sum_is_odd {

}

*the block forms* （there’s no comma between the block and the input list）
my @word = grep  {$_[0] =~ /$_/ } @wordList;

*check which links are no longer good*
use HTTP::SimpleLinkChecker qw(check_link);
my @good_links = grep {
check_link( $_ );
  ! $HTTP::SimpleLinkChecker::ERROR;
} @links;
**** Transforming Lists with map
The map operator transforms one list into another
Our map expression is for transformation instead of testing

my @input_numbers = (1, 2, 4, 8, 16, 32, 64);
my @result = map $_ + 100, @input_numbers;
@result is 101, 102, 104, 108, 116, 132, and 164.

*making a meaningful value for each hash key*
my %hash = map { $_, 3 * $_ } @input_numbers;
**** Trapping Errors with eval
eval { $average = $total / $count } ;
print "Continuing after error: $@" if $@;

As a function, eval has a return value much like a subroutine’s

*Dynamic Code with eval*
foreach my $operator ( qw(+ ? * /) ) {
  my $result = eval "2 $operator 2";
  print "2 $operator 2 is $result\n";
}
**** The do Block
*The do block is one powerful but overlooked feature of Perl*

my $bowler;
if( ...some condition... ) {
  $bowler = 'Mary Ann';
}
elsif( ... some condition ... ) {
  $bowler = 'Ginger';
}
else {
  $bowler = 'The Professor';
}

my $bowler = do {
  if( ... some condition ... ) { 'Mary Ann' }
  elsif( ... some condition ... ) { 'Ginger' }
  else { 'The Professor' }
};

do $filename;
The do finds the file and reads it.then hands off the contents to the string form of eval to execute it

require:
do the things at run time;
use:
do the things at compile time;
*** Introduction to References
**** Doing the Same Task on Many Arrays
sub check_required_items {
 my $who = shift;
 my %whos_items = map { $_, 1 } @_; # the rest are the person's items
 my @required = qw(preserver sunscreen water_bottle jacket) ;
 for my $item (@required) {
 unless ( $whos_items{$item} ) { # not found in list?
 print "$who is missing $item.\n";
 }
 }
}
my @gilligan = qw(red_shirt hat lucky_socks water_bottle) ;
check_required_items('gilligan' , @gilligan);

*Although this code meets the initial requirements, we’ve got two problems to deal with:*
- To create @_, Perl copies the entire contents of the array we want to check. This is
fine for a few items, but if the array is large, it seems a bit wasteful to copy the data
just to pass it into a subroutine.
- Suppose we want to modify the original array to force the provisions list to include
the mandatory items. Because we have a copy in the subroutine (“pass by value”),
any changes we make to @_ aren’t reflected automatically in the corresponding
provisions array.

**** Taking a Reference to an Array
*A reference to the array is like a pointer:1 it points at
the array, but is not the array itself*
my $ref_to_skipper = \@skipper;
**** Dereferencing the Array Reference
#+BEGIN_EXAMPLE perl
my @skipper = qw(blue_shirt hat jacket preserver sunscreen) ;
check_required_items("The Skipper", \@skipper);
sub check_required_items {
 my $who = shift;
 my $items = shift;
#(we can eliminated with my %whos_items = map {$_, 1} @{$_[ 1]};)
 my %whos_items = map { $_, 1 } @{$items};
 my @required = qw(preserver sunscreen water_bottle jacket) ;
 for my $item (@required) {
   unless ( $whos_items{$item} ) { # not found in list?
     print "$who is missing $item.\n";
   }
 }
}

#+END_EXAMPLE

All we did was replace @_ (the copy of the provisions list) with @{$items},

Passing the array by reference fixes the first of the two problems we mentioned earlier.

*This is one of the most important uses of references:*
decoupling the code from the data structure on which it operates so we can reuse the
code more readily.

both of these lines refer to the entire array:
  @ skipper
  @{ $items }
whereas both of these refer to the second item of the array:2
  $ skipper [ 1]
  ${ $items }[ 1]
**** Getting Our Braces Off
@{$items} or ${$items}[1] => @$items or $$items[1]
**** Nested Data Structures
#+BEGIN_SRC perl

my @skipper = qw(blue_shirt hat jacket preserver sunscreen) ;
my @skipper_with_name = ('Skipper' => \@skipper);

my @professor = qw(sunscreen water_bottle slide_rule batteries radio) ;
my @professor_with_name = ('Professor' => \@professor);

my @all_with_names = (
 \@skipper_with_name,
 \@professor_with_name,
);

for my $person (@all_with_names) {
 my $who = $$person[0];
 my $provisions_reference = $$person[1];
 check_required_items($who, $provisions_reference);
}

=> for my $person (@all_with_names) {
     check_required_items(@$person);
   }

or even:
check_required_items(@$_) for @all_with_names;
#+END_SRC
**** Simplifying Nested Element References with Arrows
Everywhere we write ${DUMMY}[$y] , we can write DUMMY->[$y]  instead

we can pick out the array reference for Gilligan with a simple $all_with_names[2]->[1] ,
and Gilligan’s first provision with $all_with_names[2]->[1]->[0] .
$all_with_names[2]->[1]->[0]  becomes $all_with_names[2][1][0]

imagine a reference to the array @all_with_names:
my $root = \@all_with_names;
we get to Gilligan’s first item using the “drop arrow” rule, we can use:
$root -> [2][1][0](We cannot drop the first arrow)

If we want all of Gilligan’s provisions, we say:
@{$root->[2][1]}
**** References to Hashes
#+BEGIN_SRC perl
my %gilligan_info = (
  name => 'Gilligan' ,
  hat => 'White' ,
  shirt => 'Red' ,
  position => 'First Mate' ,
);
my $hash_ref = \%gilligan_info;

my $name = $ gilligan_info { 'name' };
my $name = $ { $hash_ref } { 'name' };
my @keys = keys % gilligan_info;
my @keys = keys % { $hash_ref };

we can drop the curly braces:
my $name = $$hash_ref{'name' };
my @keys = keys %$hash_ref;

we can use an arrow form
my $name = $hash_ref?>{'name' };

my @crew = (\%gilligan_info, \%skipper_info);
We can get to Gilligan’s name via any one of:
${ $crew[ 0] } { 'name' }
my $ref = $crew[ 0]; $$ref{'name' }
$crew[ 0] ->{'name' }
$crew[ 0]{'name' }

my $format = "%?15s %?7s %?7s %?15s\n";
printf $format, qw(Name Shirt Hat Position) ;
foreach my $crewmember (@crew) {
 printf $format,
  $crewmember->{'name' },
  $crewmember->{'shirt' },
  $crewmember->{'hat' },
  $crewmember->{'position' };
}

#+END_SRC

That last part looks repetitive. We can shorten it with a hash slice
Again, if the original syntax is: @ gilligan_info { qw(name position) }
the hash slice notation from a reference looks like: @ { $hash_ref } { qw(name position) }
We can drop the first brace pair because the only thing within is a simple scalar value,yielding:
  @ $hash_ref { qw(name position) }
Thus, we can replace that final loop with:
for my $crewmember (@crew) {
 printf $format, @$crewmember{qw(name shirt hat position) };
}
*There is no shortcut form with an arrow (->) for array slices or hash slices.*
**** Checking Reference Types
ref returns the reference type

use constant HASH => ref {};
croak "I expected a hash reference!"
  unless $ref_type eq HASH;

Using a constant looks a lot like a literal string, but it has an important difference:
the constant will fail if we use the wrong name because it is not defined, but a wrong literal
string will never fail

ref returns a string that gives the reference type, if we have an object that
can act like a hash reference, our technique fails because the strings won’t be the same.

The Scalar::Util module, which comes with Perl, gets around that with its reftype
function that does the same thing:
use Carp qw(croak) ;
use Scalar:: Util qw(reftype) ;
sub show_hash {
 my $hash_ref = shift;
 my $ref_type = reftype $hash_ref;  # works with objects
 croak "I expected a hash reference!"
 unless $ref_type eq ref {};
 foreach my $key ( %$hash_ref ) {
 ...
 }
}

we might use an eval in which we try to do something hash-like. If the
eval fails and returns false, we didn’t have a hash:
croak "I expected a hash reference!"
 unless eval { keys %$ref_type; 1 }
*** References and Scoping
**** More than One Reference to Data
kill off each reference: $ref_to_skipper = undef;

Perl recycles the memory for the array only when all references (including the name of the array) go away

The bottom line is this: Perl does the right thing. If we still have a reference to data, we still have the data.
**** When Reference Counting Goes Bad
my @data1 = qw(one won);
my @data2 = qw(two too to);
push @data2, \@data1;
push @data1, \@data2;
this  creates a memory leak,

... use @data1, @data2 ...
# at the end:
@data1 = ( );
@data2 = ( );
**** Creating an Anonymous Array Directly
sub get_provisions_list {
    my @skipper = qw(blue_shirt hat jacket preserver sunscreen);
    my @skipper_with_name = ('The Skipper', \@skipper);
    my @professor = qw(sunscreen water_bottle slide_rule batteries radio);
    my @professor_with_name = ('The Professor', \@professor);
    my @gilligan = qw(red_shirt hat lucky_socks water_bottle);
    my @gilligan_with_name = ('Gilligan', \@gilligan);
    return (
        \@skipper_with_name,
        \@professor_with_name,
        \@gilligan_with_name,
        );
}

*Any time we need an element of a list to be a reference to an array,
we can create that reference with an anonymous array constructor*

We can also nest them in our provisions list:
sub get_provisions_list {
    return (
        ['The Skipper', [qw(blue_shirt hat jacket preserver sunscreen) ] ],
        ['The Professor', [qw(sunscreen water_bottle slide_rule batteries radio) ] ],
        ['Gilligan', [qw(red_shirt hat lucky_socks water_bottle) ] ],
     );
}
my @all_with_names = get_provisions_list( );

*The square brackets take the value within (evaluated in list context); establish a new,
anonymous array initialized to those values; and (here’s the important part) return a reference to that array.*
**** Creating an Anonymous Hash
my %gilligan_info = (
    name => 'Gilligan',
    hat => 'White',
    shirt => 'Red',
    position => 'First Mate',
);
my %skipper_info = (
    name => 'Skipper',
    hat => 'Black',
    shirt => 'Blue',
    position => 'Captain',
);
my @crew = (\%gilligan_info, \%skipper_info);

we can avoid the temporary variables and insert the values directly into the top-level list
my @crew = (
{
    name => 'Gilligan',
    hat => 'White',
    shirt => 'Red',
    position => 'First Mate',
},
{
    name => 'Skipper',
    hat => 'Black',
    shirt => 'Blue',
    position => 'Captain',
},
);

To show the compiler that we want an anonymous hash constructor,
put a plus sign before the opening curly brace: +{ ... }. To get a block of code,
put a semicolon (representing an empty statement) at the beginning of the block: {; ... }.
**** TODO Autovivification(自动展开，自动生成)
**** TODO Autovivification and Hashes
** Advanced perl
*** 模块
**** 包的基本知识
package ATM; #开始一个新的名字空间
BankAccount::deposit(10); #调用一个外部子例程
print $BankAccount::total;#获取一个外部变量
** code
*** 读取文件修改内容，生成新文件
#+BEGIN_EXAMPLE perl
use strict;
use UTF8;
use Encode;
open(my $file,"<:encoding(UTF-8)","MemoAction.java")||die"cannot open the file: $!\n";
open(my $newfile, ">:encoding(UTF-8)","NewMemo.java") || die "open file die:$!\n";
my @linelist=<$file>;
foreach my $linelist(@linelist){
   #print $linelist;
   #$linelist =~ s/memo/哈哈/;
   my $str1 = Encode::decode_utf8("水单");
   my $str2 = Encode::decode_utf8("哈哈");
   $linelist =~ s/$str1/$str2/;
   print $newfile "$linelist";
}
close $file;
close $newfile;
#+END_EXAMPLE
*** 修改文件内容
@ARGV = "test.ini";
    local $^I='.bak';
    while (<>) {
            s/(Tom|Jerry)/$1 Male/;
            s/(Helen)/$1 Femal/;
            print;
    }

注明：
1，在linux下不需要备份文件，可以直接替换，而在windows中必须备份，
否则会出现Can't do inplace edit without backup的错误。

命令行模式
perl -p -i.bak -w -e 's/匹配模式/替换文本/g' 文件名列表
直接在命令行里输入上面的的命令，-p表示自动生成
while (<>) {
print;
}
-i.bak表示原文件被重命名，增加.bak扩展名
-w打开警告
-e后面的单引号里的字符串作为程序执行
*** 连接数据库
#+BEGIN_EXAMPLE perl

my $dbname = "book";            # 数据库名
my $location = "localhost";     # 地址
my $port = "3306";              # 端口
my $db_user = "root";           # 用户名
my $db_pass = "1234";           # 密码
my $dbh = DBI->connect($database,$db_user,$db_pass);
$dbh->do("SET NAMES utf8");
my $sql = "SELECT *  FROM users";
my $sth = $dbh->prepare($sql);#准备
$sth->execute() or die "无法执行SQL语句:$dbh->errstr"; #执行
while (my @data = $sth->fetchrow_array()) {#fetchrow_array返回row
print "Email:$data[0]\t Telephone:$data[1]\n";
}
$sth->finish();
$dbh->disconnect;#断开数据库连接
#+END_EXAMPLE
** script
*** 全局修改某文件夹下文件内容脚本
use strict;
use UTF8;
use File::Find::Rule;
use Encode;

my $directory = "F:\\wmy_cms";  # 目标文件夹
my $regex = ".*SysUser.*";      # 目标文件
my $old_string = "sysUser";     # 需要替换的字符串
my $new_string = Encode::decode_utf8("哈哈");# 新字符串

# find all the  files
my @files = File::Find::Rule->file()->name(qr/$regex/)->in( $directory );
local $^I='.bak';
@ARGV = @files;
while(<>){
    s/$old_string/$new_string/g;
    print;
}

# 删除.bak文件

my @files_bak = File::Find::Rule->file() ->name('*.bak')->in( $directory );

unlink @files_bak;

*** 批量读取文件夹下的文件，修改内容，生成新文件（java代码生成脚本）
use strict;
use UTF8;
use Encode;
use File::Find::Rule;
use File::Spec;
use File::Basename;

my $directory = "F:\\wmy_cms";  # 目标文件夹

my $old_china_string = Encode::decode_utf8("服务人员"); # 需要替换的汉字
my $new_china_string = Encode::decode_utf8("测试");         # 新的汉字

my $old_string = "ServicePerson";     # 需要替换的字符串
my $new_string = "Demo7";             # 新的字符串
my $s_old_string = lcfirst($old_string); #字符串首字母小写
my $s_new_string  = lcfirst($new_string);

my @files = File::Find::Rule->file()->name(qr/.*$old_string.*/)->in( $directory );

foreach my $oldfile(@files){
    print "$oldfile\n";
    my $dir_name = dirname $oldfile;
    my $base_name = basename $oldfile;
    my $new_base_name = $base_name =~ s/$old_string/$new_string/gr;
    my $new_full_name = File::Spec->catfile($dir_name,$new_base_name);
    #打开文件
    open(my $tmp_oldfile,"<:encoding(UTF-8)",$oldfile)||die"cannot open the file: $!\n";
    #打开新文件
    open(my $tmp_newfile, ">:encoding(UTF-8)",$new_full_name) || die "open file die:$!\n";
    my @linelist=<$tmp_oldfile>;

    #向新文件写入内容
    foreach my $linelist(@linelist){
        $linelist =~ s/$old_string/$new_string/g;
        $linelist =~ s/$s_old_string/$s_new_string/g;
        $linelist =~ s/$old_china_string/$new_china_string/g;
        print $tmp_newfile "$linelist";
    }
    close $tmp_oldfile;
    close $tmp_newfile;
}

*** 根据数据库表名生成字段和注释脚本
use strict;
use UTF8;
use Encode;
use DBI;

#根据数据库表名生成字段和注释

my $tab_name = "t_shipbuild";
my $mould = "/** 注释 **/\nprivate String column_name;";

#从数据库获取字段和注释
my @data = &get_colname_and_comment($tab_name);

my @row = split(/~/,"@data");

foreach my $row (@row) {
  $row =~ s/^ +//;              # 去除数据前的空格
  my @col = split(/ /,"$row");
  my $my_column = $mould =~ s/注释/$col[1]/r;

  $my_column =~ s/column_name/$col[0]/;
  $my_column =~ s/String/Data/ if "$col[2]" eq "datetime";

  print "$my_column\n";
}


#获取指定表名的字段名，注释，字段类型
#参数：表名
#返回值 1,字段名；2，字段注释；3，字段类型
sub get_colname_and_comment{
  my $sql = "select column_name,column_comment,data_type from information_schema.columns where table_name = '$_[0]'";
  my @sql_data = &select_db($sql);
  #断开数据库连接
}

#访问数据库|返回逗号分隔数据的数组
#参数：sql语句
sub select_db{
  my $dbname = "db_wmy";       # 数据库名
  my $location = "192.168.1.151";   # 地址
  my $port = "3306";            # 端口
  my $db_user = "caojian";         # 用户名
  my $db_pass = "caojian";         # 密码
  my $database = "DBI:mysql:$dbname:$location:$port";
  my $dbh = DBI->connect($database,$db_user,$db_pass);
  $dbh->do("SET NAMES utf8");
  my $sth = $dbh->prepare($_[0]);                        #准备
  $sth->execute() or die "无法执行SQL语句:$dbh->errstr"; #执行
  my @need_data;
  while (my @data = $sth->fetchrow_array()) { #fetchrow_array返回row
    push(@need_data,"@data~");
  }
  $sth->finish();
  $dbh->disconnect;
  @need_data;
}

*** create_mysql.pl
use strict;
use UTF8;
use Encode;
use DBI;
#根据数据库字段、注释和模板生成代码

my $tab_name = "t_ship";        # 表名

my $dbname = "db_ship";          # 数据库名

#查询模板
my $mould = "    t.column_name,";
#更新模板
my $update_mould =  "    <if test=\"lower_name != '' and lower_name != null\">\n        t.column_name = #{lower_name},\n    </if>";
# 数据库日期类型
#my $db_date_type = "timestamp";
my $db_date_type = "datetime";

#查询时日期模板 %Y年%m月%d日 %T
my $date_mould = "    DATE_FORMAT(t.column_name,'%Y年%m月%d日') AS column_name,";

my $key_id = "";                # 主键
my $lower_key_id = "";          # 主键小写

#从数据库获取字段和注释
my @data = &get_colname_and_comment($tab_name,$dbname);

my @row = split(/~/,"@data");

#获取主键
foreach my $row (@row) {
  $row =~ s/^ +//;              # 去除数据前的空格
  my @col = split(/ /,"$row");
  $key_id = $col[0];
  $lower_key_id = lc($col[0]);
  last;
}


#打印语句
print "<!-----------查询语句:------------------>\n";
my $select_sql;
$select_sql .= "SELECT\n";

foreach my $row (@row) {
  $row =~ s/^ +//;              # 去除数据前的空格
  my @col = split(/ /,"$row");
  my $my_column;
  if("$col[2]" eq $db_date_type){
     $my_column = $date_mould =~ s/column_name/$col[0]/gr;
  }else{
     $my_column = $mould =~ s/column_name/$col[0]/gr;
  }
  $select_sql .= "$my_column\n";
}
$select_sql =~ s/,$//;
$select_sql .= "FROM $tab_name t\nWHERE t.DELFLAG = 0\n";

print $select_sql;

print "<!-----------新增语句：-------------------->\n";
my $insert_sql;
$insert_sql .= "insert into $tab_name\n    (\n";

foreach my $row (@row) {
  $row =~ s/^ +//;              # 去除数据前的空格
  my @col = split(/ /,"$row");
  $insert_sql .= "        $col[0],\n" unless $key_id eq $col[0];
}
$insert_sql =~ s/,$//;

$insert_sql .= "    )values(\n";

foreach my $row (@row) {
  $row =~ s/^ +//;              # 去除数据前的空格
  my @col = split(/ /,"$row");
  my $my_lower_column = lc($col[0]);
  $insert_sql .= "        #{$my_lower_column},\n" unless $key_id eq $col[0];;
}
$insert_sql =~ s/,$//;
$insert_sql .= ")\n";
print $insert_sql;


print "<!-----------修改语句：-------------------->\n";
my $update_sql;
$update_sql .= "update $tab_name t\n<set>\n";

foreach my $row (@row) {
  $row =~ s/^ +//;              # 去除数据前的空格
  my @col = split(/ /,"$row");
  my $my_column;
  $my_column = $update_mould =~ s/column_name/$col[0]/gr;
  my $my_lower_column = lc($col[0]);
  $my_column =~ s/lower_name/$my_lower_column/g;
  $my_column = (split(/[\n]/s, $my_column))[1] if $col[3] eq"YES";
  $update_sql .= "$my_column\n" unless $key_id eq $col[0];
}
$update_sql .= "<set>\n<where>\n    t.DELFLAG = 0\n    AND t.$key_id = #$lower_key_id#\n</where>\n";
print $update_sql;


#获取指定表名的字段名，注释，字段类型
#参数：表名
#返回值 1,字段名；2，字段注释；3，字段类型；4，是否可以为空
sub get_colname_and_comment{
  #mysql查询字段语句
  my $sql = "select column_name,column_comment,data_type,is_nullable from information_schema.columns where table_name = '$_[0]' and table_schema = '$_[1]'";

  my @sql_data = &select_db($sql);

}


#访问数据库|返回逗号分隔数据的数组
#参数：sql语句
sub select_db{

  # my $location = "192.168.1.151";   # 地址
  # my $port = "3306";            # 端口
  # my $db_user = "caojian";         # 用户名
  # my $db_pass = "caojian";         # 密码;
  my $location = "localhost";   # 地址
  my $port = "3306";            # 端口
  my $db_user = "root";         # 用户名
  my $db_pass = "1234";         # 密码;
  my $database = "DBI:mysql:$dbname:$location:$port";
  my $dbh = DBI->connect($database,$db_user,$db_pass);

  $dbh->do("SET NAMES utf8");
  my $sth = $dbh->prepare($_[0]);                        #准备
  $sth->execute() or die "无法执行SQL语句:$dbh->errstr"; #执行
  my @need_data;

  while (my @data = $sth->fetchrow_array()) { #fetchrow_array返回row
    push(@need_data,"@data~");
  }

  $sth->finish();
  $dbh->disconnect; #断开数据库连接
  @need_data;
}

*** quick_create(mysql).pl
use strict;
use UTF8;
use Encode;
use DBI;
#根据数据库字段、注释和模板生成代码

my $tab_name = "t_ship";        # 表名

my $dbname = "db_ship";          # 数据库名

#模板类型 1:dto,2:html,3:jsrequired,4:common
my $mould_type = '2';

#dto模板
my $dto_mould = "/** 注释 **/\nprivate String column_name;";

#html模板
#新增修改页面必填字端样式
my $need_class = "<label class=\"need\"></label>";

my $html_mould = '<tr>
    <td width="100px" class="text_right td_backColor">名称：</td>
    <td ><div ><input type="text" id="column_name" placeholder="请输入虚文字" maxlength="column_length"  name="column_name" value=""/></div></td>
</tr>';

#common模板
#my $common_mould = "\$('#v_column_name').text(data.column_name);";

#my $common_mould = "column_name:{\n    required:true, \n},";
my $common_mould = "column_name:{\n    required:\"注释不能为空\", \n},";

# 数据库日期类型
#my $db_date_type = "timestamp";
my $db_date_type = "datetime";

#从数据库获取字段和注释
my @data = &get_colname_and_comment($tab_name,$dbname);

my @row = split(/~/,"@data");

foreach my $row (@row) {
  $row =~ s/^ +//;              # 去除数据前的空格
  my @col = split(/ /,"$row");
  my $my_column;
  if($mould_type eq "1"){
     $my_column = $dto_mould =~ s/注释/$col[1]/gr;
     $my_column =~ s/String/Date/ if "$col[2]" eq "$db_date_type";
  }elsif($mould_type eq "2"){
        if($col[3] eq "NO"){
            $my_column = $html_mould =~ s/虚文字/$col[1]/gr;
            $my_column =~ s/名称/$need_class$col[1]/g;
        }else{
            $my_column = $html_mould =~ s/名称/$col[1]/gr;
            $my_column =~ s/虚文字/$col[1]/g;
        }
        my $max_length;
        if($col[2] =~ /(\d+)/){$max_length = $1;}
        $my_column =~ s/column_length/$max_length/;
  }elsif($mould_type eq "3"){
      if($col[3] eq "NO"){
          $my_column = $common_mould =~ s/注释/$col[1]/gr;
           my $lower_name = lc($col[0]);
          $my_column =~ s/column_name/$lower_name/g;

          print "$my_column\n";
      }
  }elsif($mould_type eq "4"){
      $my_column = $common_mould =~ s/注释/$col[1]/gr;
  }
  if($mould_type != "3"){
      my $lower_name = lc($col[0]);
      $my_column =~ s/column_name/$lower_name/g;

      print "$my_column\n";
  }

}


#获取指定表名的字段名，注释，字段类型
#参数：表名
#返回值 1,字段名；2，字段注释；3，字段类型加长度；4，是否可以为空
sub get_colname_and_comment{
  #mysql查询字段语句
  my $sql = "select column_name,column_comment,column_type,is_nullable from information_schema.columns where table_name = '$_[0]' and table_schema = '$_[1]'";

  my @sql_data = &select_db($sql);
}


#访问数据库|返回逗号分隔数据的数组
#参数：sql语句
sub select_db{

  # my $location = "192.168.1.151";   # 地址
  # my $port = "3306";            # 端口
  # my $db_user = "caojian";         # 用户名
  # my $db_pass = "caojian";         # 密码;
  my $location = "localhost";   # 地址
  my $port = "3306";            # 端口
  my $db_user = "root";         # 用户名
  my $db_pass = "1234";         # 密码;
  my $database = "DBI:mysql:$dbname:$location:$port";
  my $dbh = DBI->connect($database,$db_user,$db_pass);

  $dbh->do("SET NAMES utf8");
  my $sth = $dbh->prepare($_[0]);                        #准备
  $sth->execute() or die "无法执行SQL语句:$dbh->errstr"; #执行
  my @need_data;

  while (my @data = $sth->fetchrow_array()) { #fetchrow_array返回row
    push(@need_data,"@data~");
  }

  $sth->finish();
  $dbh->disconnect; #断开数据库连接
  @need_data;
}

*** create_oracle.pl
use strict;
use UTF8;
use Encode;
use DBI;
#根据数据库字段、注释和模板生成代码

my $tab_name = "T_F1_ORDER";        # 表名

#查询模板
my $mould = "    t.column_name,";
#更新模板
my $update_mould_must =  "    <isNotEmpty  prepend=\",\" property=\"lower_name\">\n        t.column_name = #lower_name#\n    </isNotEmpty>";
my $update_mould = "    <isNotNull prepend=\",\" property=\"lower_name\">\n        t.column_name = #lower_name#\n    </isNotNull>";
# 数据库日期类型
#my $db_date_type = "timestamp";
my $db_date_type = "DATE";
my $db_price = "PRICE";

#查询时日期模板 %Y年%m月%d日 %T
my $date_mould = "    TO_CHAR(t.column_name, 'yyyy-MM-dd hh24:mi') AS column_name,";
my $price_mould = "    nvl(TO_CHAR(t.column_name, 'fm9999999990.00'),'0.00') AS t.column_name,";

my $key_id = "";                # 主键
my $lower_key_id = "";          # 主键小写

#从数据库获取字段和注释
my @data = &get_colname_and_comment($tab_name);

#print @data;

my @row = split(/~/,"@data");

#获取主键
foreach my $row (@row) {
  $row =~ s/^ +//;              # 去除数据前的空格
  my @col = split(/ /,"$row");
  $key_id = $col[0];
  $lower_key_id = lc($col[0]);
  last;
}


#打印语句
print "<!-----------查询语句:------------------>\n";
my $select_sql;
$select_sql .= "SELECT\n";

foreach my $row (@row) {
  $row =~ s/^ +//;              # 去除数据前的空格
  my @col = split(/ /,"$row");
  my $my_column;
  if("$col[2]" eq $db_date_type){
     $my_column = $date_mould =~ s/column_name/$col[0]/gr;
  }elsif(index($col[0],$db_price) != -1){
     $my_column = $price_mould =~ s/column_name/$col[0]/gr;
  }else{
     $my_column = $mould =~ s/column_name/$col[0]/gr;
  }
  $select_sql .= "$my_column\n";
}
$select_sql =~ s/,$//;
$select_sql .= "FROM $tab_name t\nWHERE t.DELFLAG = 0\n";

print $select_sql;

print "<!-----------新增语句：-------------------->\n";
my $insert_sql;
$insert_sql .= "insert into $tab_name\n    (\n";

foreach my $row (@row) {
  $row =~ s/^ +//;              # 去除数据前的空格
  my @col = split(/ /,"$row");
  $insert_sql .= "        $col[0],\n" unless $key_id eq $col[0];
}
$insert_sql =~ s/,$//;

$insert_sql .= "    )values(\n";

foreach my $row (@row) {
  $row =~ s/^ +//;              # 去除数据前的空格
  my @col = split(/ /,"$row");
  my $hump_word = &get_hump_word(lc($col[0]));
  $insert_sql .= "        #$hump_word#,\n" unless $key_id eq $col[0];;
}
$insert_sql =~ s/,$//;
$insert_sql .= ")\n";
print $insert_sql;


print "<!-----------修改语句：-------------------->\n";
my $update_sql;
$update_sql .= "<![CDATA[\n    update $tab_name t\n]]>\n<dynamic prepend=\"set\">\n";

foreach my $row (@row) {
  $row =~ s/^ +//;              # 去除数据前的空格
  my @col = split(/ /,"$row");
  my $my_column;
  if($col[3] eq "Y"){
      $my_column = $update_mould =~ s/column_name/$col[0]/gr;
  }else{
      $my_column = $update_mould_must =~ s/column_name/$col[0]/gr;
  }
  my $hump_word = &get_hump_word(lc($col[0]));
  $my_column =~ s/lower_name/$hump_word/g;
  $update_sql .= "$my_column\n" unless $key_id eq $col[0];
}
$update_sql .= "</dynamic>\n<![CDATA[\n    where t.$key_id = #$lower_key_id#\n]]>\n";
print $update_sql;


#获取指定表名的字段名，注释，字段类型
#参数：表名
#返回值 1,字段名；2，字段注释；3，字段类型；4，是否可以为空
sub get_colname_and_comment{

  #oracle查询字段语句
  my $sql = "select t.COLUMN_NAME,(select c.comments from user_col_comments c where c.table_name = t.TABLE_NAME and c.column_name = t.COLUMN_NAME) as comments,t.DATA_TYPE,t.NULLABLE from user_tab_columns t where t.table_name = '$tab_name'";
  my @sql_data = &select_db($sql);
  #断开数据库连接
}

#访问数据库~返回逗号分隔数据的数组
#参数：sql语句
sub select_db{

  my $dbname = "192.168.1.151:1521/TESTDATA";       # 数据库名
  my $db_user = "test";         # 用户名
  my $db_pass = "test2015";         # 密码
  my $database = "DBI:Oracle://$dbname";
  my $dbh = DBI->connect($database,$db_user,$db_pass,{ora_charset => 'AL32UTF8'});

  my $sth = $dbh->prepare($_[0]);                        #准备
  $sth->execute() or die "无法执行SQL语句:$dbh->errstr"; #执行
  my @need_data;
  while (my @data = $sth->fetchrow_array()) { #fetchrow_array返回row
    push(@need_data,"@data~");
  }
  $sth->finish();
  $dbh->disconnect;
  @need_data;
}

# 获取驼峰字符串
sub get_hump_word{

    my $wordFile = "word.txt";
    #打开文件
    open(my $tmp_file,"<:encoding(UTF-8)",$wordFile)||die"cannot open the file: $!\n";
    my @linelist=<$tmp_file>;
    my @wordList;

    foreach my $linelist(@linelist){
        chomp(@linelist);
        push(@wordList,split(/,/,$linelist));
    }
    my @word = grep  {$_[0] =~ /$_/ }  @wordList;
    my $result = $_[0];
    foreach my $word (@word){
        my $uc_first_word = ucfirst($word);
        $result =~ s/$word/$uc_first_word/g;
    }
    close $tmp_file;
    return lcfirst($result);

}

*** quick_create(oracle).pl
use strict;
use UTF8;
use Encode;
use DBI;
binmode(STDIN, ':encoding(utf8)');

binmode(STDOUT, ':encoding(utf8)');

binmode(STDERR, ':encoding(utf8)');
#根据数据库字段、注释和模板生成代码

my $tab_name = "T_F1_ORDER";        # 表名

#模板类型 1:dto,2:html,3:jsrequire,4:common(vo)
my $mould_type = '1';

#dto模板
my $dto_mould = "/** 注释 **/\nprivate String column_name;";

#html模板
#新增修改页面必填字端样式
my $need_class = "<span style=\"color: red\">* </span>";

my $utf_string_html = Encode::decode_utf8("请输入");         # 新的汉字

# my $html_mould = "<tr>
#     <td width=\"150px\" class=\"text-right td_backColor\">名称:</td>
#     <td ><div ><input type=\"text\" class=\"form-control\" id=\"column_name\" placeholder=\"$utf_string_html虚文字\" maxlength=\"column_length\"  name=\"column_name\" value=\"\"/></div></td>
# </tr>";
my $html_mould = "<tr>
    <td width=\"150px\" class=\"text-right td_backColor\">名称:</td>
    <td ><span id=\"v_column_name\"></span></td>
</tr>";

my $utf_string1 = Encode::decode_utf8("不能为空"); # 解决乱码

#common模板
#my $common_mould = "\$('#v_column_name').text(data.column_name);";
my $common_mould = "\$('#a_column_name').val(data.column_name);";

#my $common_mould = "column_name:{\n    required:true, \n},";
#my $common_mould = "column_name:{\n    required:\"注释$utf_string1\", \n},";
#my $common_mould = "<th>注释</th>";
#vo模板
#my $common_mould = "/** 注释 **/\nprivate String column_name;";
# 数据库日期类型

my $db_date_type = "DATE";

#从数据库获取字段和注释
my @data = &get_colname_and_comment($tab_name);
#@data = lc("@data");
#@data = "id 主键 number 22 n~ bannerType 类型【0：默认（不可点击）；1：html链接（可点击）；2：推荐线路】 varchar2 1 n~ bannerImg 图片 varchar2 50 n~ bannerUrl url varchar2 50 y~ formatId 线路编号 number 22 y~ sort 排序 number 22 y~ createDate 创建时间 date 7 n~";
my @row = split(/~/,"@data");

foreach my $row (@row) {
  $row =~ s/^ +//;              # 去除数据前的空格
  my @col = split(/ /,"$row");
  my $my_column;
  if($mould_type eq "1"){
     $my_column = $dto_mould =~ s/注释/$col[1]/gr;
     $my_column =~ s/String/Date/ if "$col[2]" eq "$db_date_type";
  }elsif($mould_type eq "2"){
        if($col[4] eq "N"){
            $my_column = $html_mould =~ s/虚文字/$col[1]/gr;
            $my_column =~ s/名称/$need_class$col[1]/g;
        }else{
            $my_column = $html_mould =~ s/名称/$col[1]/gr;
            $my_column =~ s/虚文字/$col[1]/g;
        }

        $my_column =~ s/column_length/$col[3]/;
  }elsif($mould_type eq "3"){
      if($col[4] eq "N"){
          $my_column = $common_mould =~ s/注释/$col[1]/gr;
          my $hump_word = &get_hump_word(lc($col[0]));
          $my_column =~ s/column_name/$hump_word/g;
          print "$my_column\n";
      }
  }elsif($mould_type eq "4"){
      $my_column = $common_mould =~ s/注释/$col[1]/gr;
  }
  if($mould_type != "3"){
      my $hump_word = &get_hump_word(lc($col[0]));
      $my_column =~ s/column_name/$hump_word/g;
      print "$my_column\n";

  }

}

#获取指定表名的字段名，注释，字段类型
#参数：表名
#返回值 1,字段名；2，字段注释；3，字段类型,4,字段长度，5是否可以为空
sub get_colname_and_comment{

  #oracle查询字段语句
  my $sql = "select t.COLUMN_NAME,(select c.comments from user_col_comments c where c.table_name = t.TABLE_NAME and c.column_name = t.COLUMN_NAME) as comments,t.DATA_TYPE,t.DATA_LENGTH,t.NULLABLE from user_tab_columns t where t.table_name = '$tab_name'";
  my @sql_data = &select_db($sql);
  #断开数据库连接
}

#访问数据库~返回逗号分隔数据的数组
#参数：sql语句
sub select_db{

  my $dbname = "192.168.1.151:1521/TESTDATA";       # 数据库名
  my $db_user = "test";         # 用户名
  my $db_pass = "test2015";         # 密码
  my $database = "DBI:Oracle://$dbname";
  my $dbh = DBI->connect($database,$db_user,$db_pass,{ora_charset => 'AL32UTF8'});

  my $sth = $dbh->prepare($_[0]);                        #准备
  $sth->execute() or die "无法执行SQL语句:$dbh->errstr"; #执行
  my @need_data;
  while (my @data = $sth->fetchrow_array()) { #fetchrow_array返回row
    push(@need_data,"@data~");
  }
  $sth->finish();
  $dbh->disconnect;
  @need_data;
}

# 获取驼峰字符串
sub get_hump_word{

    my $wordFile = "word.txt";
    #打开文件
    open(my $tmp_file,"<:encoding(UTF-8)",$wordFile)||die"cannot open the file: $!\n";
    my @linelist=<$tmp_file>;
    my @wordList;

    foreach my $linelist(@linelist){
        chomp(@linelist);
        push(@wordList,split(/,/,$linelist));
    }
    my @word = grep  {$_[0] =~ /$_/ }  @wordList;
    my $result = $_[0];
    foreach my $word (@word){
        my $uc_first_word = ucfirst($word);
        $result =~ s/$word/$uc_first_word/g;
    }
    close $tmp_file;
    return lcfirst($result);

}
*** write_method.pl(ejy)
use strict;
use UTF8;
use Encode;
use File::Find::Rule;
use File::Basename;


#向文件中写入方法

my $directory = "D:\\eclipse_workspace\\ejycxtx\\src\\com\\ejycxtx";  # 目标文件夹
my $fileRegex = ".*Order.*";    # 目标文件

my $methodName = "getOrderSum";            # 方法名
my $beanName = "Order";            # bean
my $lowerBeanName = lcfirst($beanName);       # bean首字母小写
my $methodNote = "查询订单数目";    # 方法注释
#方法类型 1:get rvo,2:insert,3:update,4:get list,5,get int
my $method_type = "5";

#匹配文件
my $actionRegex = "${beanName}Action\.java";
my $serviceRegex = "${beanName}Biz\.java";
my $serviceImplRegex = "${beanName}BizImpl\.java";
my $daoRegex = "${beanName}Dao\.java";
my $daoImplRegex = "${beanName}DaoImpl\.java";
my $xmlRegex = "${beanName}\.xml";

#匹配位置
my $match_position = "^}";
my $xml_match_position = "</sqlMap>";

#方法模板
my $actionMould;
my $serviceMould;
my $serviceImplMould;
my $daoMould;
my $daoImplMould;
my $xmlMould;

#获取本地时间
my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime;
$year += 1900; # $year是从1900开始计数的，所以$year需要加上1900；
$mon += 1; # $mon是从0开始计数的，所以$mon需要加上1；
my $datetime = sprintf ("%d-%02d-%02d %02d:%02d:%02d", $year,$mon,$mday,$hour,$min,$sec);

$actionMould = "    /**
     * $methodNote
     * \@param session
     * \@param request
     * \@param ${lowerBeanName}VO
     * \@return
     * \@author lz
     * \@date $datetime
     */
    \@ResponseBody
    \@RequestMapping(value = \"\/$methodName\")
    public String $methodName(HttpSession session, \@RequestBody ${beanName}VO ${lowerBeanName}VO) {

        log.info(GlobalContract.LOG_BEGIN);
        ResultVO resultVO = null;

        try {
            //调用业务层
            resultVO = ${lowerBeanName}Biz.$methodName(session, ${lowerBeanName}VO);
        } catch (Exception e) {
            e.printStackTrace();
            resultVO = new ResultVO(GlobalMessage.MSG_01);
            log.error(\"错误参数：\" + JSONObject.fromObject(${lowerBeanName}VO).toString());
            log.error(\"错误信息：\" + e.getMessage());
        }

            log.info(GlobalContract.LOG_END);
            return JSONObject.fromObject(resultVO).toString();
    }";


$serviceMould = "    \/**
     * $methodNote
     * \@param ${lowerBeanName}VO
     * \@return
     * \@author lz
     * \@date $datetime
     */
    public ResultVO $methodName(HttpSession session, ${beanName}VO ${lowerBeanName}VO) throws Exception;";


if($method_type eq "1"){
    $serviceImplMould = "    /**
     * $methodNote
     * \@param ${lowerBeanName}VO
     * \@return
     * \@author lz
     * \@date $datetime
     */
    \@Override
    public ResultVO $methodName(HttpSession session,${beanName}VO ${lowerBeanName}VO) throws Exception{
        log.info(GlobalContract.LOG_BEGIN);
        ResultVO resultVO = new ResultVO();
        ${beanName}RVO rvo = ${lowerBeanName}Dao.$methodName(${lowerBeanName}VO);
        resultVO.setResData(JSONObject.fromObject(rvo).toString());
        log.info(GlobalContract.LOG_END);
        return resultVO;
    }";
    $daoMould = "    /**
     * $methodNote
     * \@param ${lowerBeanName}VO
     * \@return
     * \@author lz
     * \@date $datetime
     */
    public ${beanName}RVO $methodName(${beanName}VO ${lowerBeanName}VO) throws SQLException;";
    $daoImplMould = "    /**
     * $methodNote
     * \@author lz
     * \@param ${lowerBeanName}VO
     * \@time $datetime
     * \@throws SQLException
     */
    \@Override
    public ${beanName}RVO $methodName(${beanName}VO ${lowerBeanName}VO) throws SQLException {

        log.info(GlobalContract.LOG_BEGIN);

        ${beanName}RVO rvo = (${beanName}RVO)this.getSqlMapClientTemplate().queryForObject(\"${lowerBeanName}.$methodName\",${lowerBeanName}VO);

        log.info(GlobalContract.LOG_END);
        return rvo;
    }";
    $xmlMould = "    <!-- $methodNote -->
    <select id=\"$methodName\" parameterClass=\"${beanName}VO\"  resultClass=\"${beanName}RVO\">
        <![CDATA[

        ]]>
    </select>";
}elsif($method_type eq "2"){

    $serviceImplMould = "    /**
     * $methodNote
     * \@param ${lowerBeanName}VO
     * \@return
     * \@author lz
     * \@date $datetime
     */
    \@Override
    public ResultVO $methodName(HttpSession session,${beanName}VO ${lowerBeanName}VO) throws Exception{
        log.info(GlobalContract.LOG_BEGIN);
        ResultVO resultVO = null;
        // 封装dto
        ${beanName}Dto dto = new ${beanName}Dto();
        ${lowerBeanName}Dao.$methodName(dto);
        resultVO = new ResultVO();
        log.info(GlobalContract.LOG_END);
        return resultVO;
    }";
    $daoMould = "    /**
     * $methodNote
     * \@param ${lowerBeanName}Dto
     * \@return
     * \@throws SQLException
     * \@author lz
     * \@date $datetime
     */
    public void $methodName(${beanName}Dto ${lowerBeanName}Dto) throws SQLException;";
    $daoImplMould = "    /**
     * $methodNote
     * \@author lz
     * \@param ${lowerBeanName}Dto
     * \@time $datetime
     * \@throws SQLException
     */
    \@Override
    public void $methodName(${beanName}Dto ${lowerBeanName}Dto) throws SQLException {

        log.info(GlobalContract.LOG_BEGIN);

        this.getSqlMapClientTemplate().insert(\"${lowerBeanName}.$methodName\",${lowerBeanName}Dto);

        log.info(GlobalContract.LOG_END);

    }";
    $xmlMould = "    <!-- $methodNote -->
    <insert id=\"$methodName\"  parameterClass=\"${beanName}Dto\">
        <selectKey keyProperty=\"recPlanId\" resultClass=\"string\">
            SELECT T_F_SEQ_RECOMMENDPLAN.NEXTVAL AS recPlanId FROM DUAL
        </selectKey>
        <![CDATA[

        ]]>
    </insert>";
}elsif($method_type eq "3"){


    $serviceImplMould = "    /**
     * $methodNote
     * \@param ${lowerBeanName}VO
     * \@return
     * \@author lz
     * \@date $datetime
     */
    \@Override
    public ResultVO $methodName(HttpSession session,${beanName}VO ${lowerBeanName}VO) throws Exception{
        log.info(GlobalContract.LOG_BEGIN);
        ResultVO resultVO = null;
        // 封装dto
        ${beanName}Dto dto = new ${beanName}Dto();
        ${lowerBeanName}Dao.$methodName(dto);
        resultVO = new ResultVO();
        log.info(GlobalContract.LOG_END);
        return resultVO;
    }";
    $daoMould = "    /**
     * $methodNote
     * \@param ${lowerBeanName}Dto
     * \@return
     * \@throws SQLException
     * \@author lz
     * \@date $datetime
     */
    public void $methodName(${beanName}Dto ${lowerBeanName}Dto) throws SQLException;";
    $daoImplMould = "    /**
     * $methodNote
     * \@author lz
     * \@time  $datetime
     * \@param ${lowerBeanName}Dto
     * \@throws SQLException
     */
    \@Override
    public void $methodName(${beanName}Dto ${lowerBeanName}Dto) throws SQLException {

        log.info(GlobalContract.LOG_BEGIN);

        this.getSqlMapClientTemplate().update(\"${lowerBeanName}.$methodName\",${lowerBeanName}Dto);

        log.info(GlobalContract.LOG_END);

    }";
    $xmlMould = "    <!-- $methodNote -->
    <update id=\"$methodName\"  parameterClass=\"${beanName}Dto\">

    </update>";
}elsif($method_type eq "4"){


    $serviceImplMould = "    /**
     * $methodNote
     * \@param ${lowerBeanName}VO
     * \@return
     * \@author lz
     * \@date $datetime
     */
    \@Override
    public ResultVO $methodName(HttpSession session,${beanName}VO ${lowerBeanName}VO) throws Exception{
        log.info(GlobalContract.LOG_BEGIN);
        ResultVO resultVO = null;

        List<${beanName}RVO> list = ${lowerBeanName}Dao.$methodName(${lowerBeanName}VO);

        // 返回数据
        JSONObject json = new JSONObject();
        json.put(\"list\", JSONArray.fromObject(list));
        resultVO = new ResultVO();
        resultVO.setResData(json.toString());

        log.info(GlobalContract.LOG_END);
        return resultVO;
    }";
    $daoMould = "    /**
     * $methodNote
     * \@param ${lowerBeanName}VO
     * \@return
     * \@throws SQLException
     * \@author lz
     * \@date $datetime
     */
    public List<${beanName}RVO> $methodName(${beanName}VO ${lowerBeanName}VO) throws SQLException;";
    $daoImplMould = "    /**
     * $methodNote
     * \@author lz
     * \@time $datetime
     * \@param ${lowerBeanName}VO
     * \@return
     * \@throws SQLException
     */
    \@SuppressWarnings(\"unchecked\")
    \@Override
    public List<${beanName}RVO> $methodName(${beanName}VO ${lowerBeanName}VO) throws SQLException {

        log.info(GlobalContract.LOG_BEGIN);

        List<${beanName}RVO> list = this.getSqlMapClientTemplate().queryForList(\"${lowerBeanName}.$methodName\",${lowerBeanName}VO);

        log.info(GlobalContract.LOG_END);
        return list;
    }";
    $xmlMould = "    <!-- $methodNote -->
    <select id=\"$methodName\" parameterClass=\"${beanName}VO\" resultMap=\"${beanName}RVO\">

    </select>";
}elsif($method_type eq "5"){


    $serviceImplMould = "    /**
     * $methodNote
     * \@param repairOrderVO
     * \@return
     * \@throws Exception
     * \@author lz
     * \@date $datetime
     */
    \@Override
    public ResultVO $methodName(HttpSession session,${beanName}VO ${lowerBeanName}VO) throws Exception {
        log.info(GlobalContract.LOG_BEGIN);
        ResultVO resultVO = null;
        resultVO = new ResultVO();

        int num = ${lowerBeanName}Dao.$methodName(${beanName}VO);

        // 返回数据
        JSONObject json = new JSONObject();
        json.put(\"num\", num);

        resultVO.setResData(json.toString());
        log.info(GlobalContract.LOG_END);
        return resultVO;
    }";
    $daoMould = "    /**
     * $methodNote
     * \@param ${lowerBeanName}VO
     * \@return
     * \@throws SQLException
     * \@author lz
     * \@date $datetime
     */
    public int $methodName(${beanName}VO ${lowerBeanName}VO) throws SQLException;";
    $daoImplMould = "    /**
     * $methodNote
     * \@author lz
     * \@param ${lowerBeanName}VO
     * \@time $datetime
     * \@return
     * \@throws SQLException
     */
    \@Override
    public int $methodName(${beanName}VO ${lowerBeanName}VO)throws SQLException {

        log.info(GlobalContract.LOG_BEGIN);

        int count = (int)this.getSqlMapClientTemplate().queryForObject(\"${lowerBeanName}.$methodName\",${lowerBeanName}VO);

        log.info(GlobalContract.LOG_END);
        return count;
    }";
    $xmlMould = "    <!-- $methodNote -->
    <select id=\"$methodName\" parameterClass=\"${beanName}VO\" resultMap=\"int\">

    </select>";
}


my @files = File::Find::Rule->file()->name(qr/$fileRegex/)->in( $directory );
local $^I='.bak';
@ARGV = @files;


while(<>){
    my $filename = basename($ARGV);
    if($filename =~ /$actionRegex/){
        s/$match_position/$actionMould\n}/;
    }elsif($filename =~ /$serviceRegex/){
        s/$match_position/$serviceMould\n}/;
    }elsif($filename =~ /$serviceImplRegex/){
        s/$match_position/$serviceImplMould\n}/;
    }elsif($filename =~ /$daoRegex/){
        s/$match_position/$daoMould\n}/;
    }elsif($filename =~ /$daoImplRegex/){
        s/$match_position/$daoImplMould\n}/;
    }elsif($filename =~ /$xmlRegex/){
        s/$xml_match_position/$xmlMould\n$xml_match_position/;
    }
    print;
}


#删除.bak文件

my @files_bat = File::Find::Rule->file() ->name('*.bak')->in( $directory );

unlink @files_bat;

*** 根据指定字符串查找文件
use strict;
use UTF8;
use File::Find::Rule;

#根据指定字符串查找文件
my $directory = "F:\\emacs-24.3\\.emacs.d";
my @files = File::Find::Rule->file()->name(qr/.*\.el$/)->in( $directory );
my $regString = ".*magit.*";

foreach my $file(@files){
    #打开文件
    open(my $tmp_file,"<:encoding(UTF-8)",$file)||die"cannot open the file: $!\n";
    my @linelist=<$tmp_file>;
    my $tmp_num = 0;
    #遍历文件
    foreach my $linelist(@linelist){
        if($linelist =~ /$regString/){
            $tmp_num = 1;
        }
    }
    print "$file\n" if $tmp_num == 1;
    close $tmp_file;

}

*** 获取驼峰字符串

my $test = "pricetotalprice";

my $hump_word = &get_hump_word($test);
print $hump_word;

sub get_hump_word{

    my $wordFile = "word.txt";
    #打开文件
    open(my $tmp_file,"<:encoding(UTF-8)",$wordFile)||die"cannot open the file: $!\n";
    my @linelist=<$tmp_file>;
    my @wordList;

    foreach my $linelist(@linelist){
        chomp(@linelist);
        push(@wordList,split(/,/,$linelist));
    }
    my @word = grep  {$_[0] =~ /$_/ }  @wordList;
    my $result = $_[0];
    foreach my $word (@word){
        my $uc_first_word = ucfirst($word);
        $result =~ s/$word/$uc_first_word/g;
    }
    close $tmp_file;
    return lcfirst($result);

}
*** 打包项目
use strict;
use UTF8;
use Archive::Zip;
use File::Copy;
use File::Path;

#设置tomcat环境变量
$ENV{'CATALINA_HOME'}='F:\\apache-tomcat-7.0.68';

#连接服务器

#关闭tomcat
#system("F:\\apache-tomcat-7.0.68\\bin\\shutdown.bat");

#清除缓存
#remove_tree('1234',{keep_root => 1});

# 打包项目
my $locTom = "F:\\apache-tomcat-7.0.68\\webapps\\ejycxtx"; # 本地tomcat路径
my $todoFile1 = "jdbc.properties";                 # 需替换的文件1
my $todoLoc1 = "WEB-INF\\classes\\com\\ejycxtx\\springmvc\\$todoFile1"; # 文件1目标地址
my $todoFile2 = "commonAjax.js";                 # 需替换的文件2
my $todoLoc2 = "js\\common\\$todoFile2";#文件2目标地址
my $zip = Archive::Zip->new();
$zip->addTree( "$locTom");
$zip->addFile( "$todoFile1", "$todoLoc1");
$zip->addFile( "$todoFile2", "$todoLoc2");
#$zip->addTree( 'F:\apache-tomcat-7.0.68\webapps\examples', 'examples' );

$zip->writeToFileNamed('C:\Users\Admin\Desktop\ejycxtx.war');

#将项目传到服务器

#启动tomcat
#system("F:\\apache-tomcat-7.0.68\\bin\\startup.bat");
*** 部署项目
F:
cd apache-tomcat-7.0.68
call F:\apache-tomcat-7.0.68\bin\shutdown.bat
rd /s/q F:\apache-tomcat-7.0.68\work\Catalina\localhost
del/s/q F:\apache-tomcat-7.0.68\webapps\
move "C:\Users\lz\Desktop\123.bat" "F:\apache-tomcat-7.0.68\webapps"
call F:\apache-tomcat-7.0.68\bin\startup.bat
** modules
*** File::Basename模块 提供和 Shell 下的 basename, dirname 功能类似的函数
从文件全名里取出基名
use File::Basename
my $name = "/user/perl"
my $basename = basename $name;#返回'perl'

dirname函数从文件全名里取得目录名称
*** File::Spec 提供了对 file name 常见操作的可移植的实现
把基名和目录名结合起来以取得文件全名
use File::Spec;
my $new_name = File::Spec->catfile($dirname,$basename);
rename($old_name,$new_name)
  or warn "can't rename"
*** Path::Class 提供了比File::Spec更友好的操作界面
use Path::Class
my $dir = dir( qw(Users fred lib));
my $subdir = $dir -> subdir('perl5'); #Users/fred/lib/perl5
my $parent = $dir->parent; #Users/fred
my $windir = $dir->as_foreign('Win32'); #Users\fred\lib
*** CGI.pm模块
CGI模块有两种风格：古朴的函数接口和面向对象接口
下面CGI脚步会解析CGI输入，并以纯文本的方式来显示输入字段的名称和值，
:all，导出标签的写法，用了指定一组要导出的函数而非一个
use CGI qw(:all);
print header('text/plain');
foreach $param ( param()){
  print "$param" .param($param)."\n";
}
输出HTML格式的结果
print header(),
  start_html("This is the page title"),
  h1("Input patam");

*** 数据库和DBI模块
安装DBI、DBD(数据库驱动程序)
连接数据库 use DBI; $dbh = DBI->connect($data_source, $username, $password);
对于PostgreSQL来说，驱动程序是DBD::Pg；
my $date_source = "dbi:Pg:dbname=name_of_database";
查询数据
my $sth = $dbh->prepare("SELECT * FROM foo WHERE bla");
$sth -> execute();
my @row_ar = $sth->fetchrow_array;
$sth -> finish;
关闭连接
$dbh->disconnect();
**** 一些变量表达的常用意思
$drh表示驱动程序对象的句柄
$dbh表示针对一个数据库对象的句柄
$sth表示针对一个语句或者一个查询对象的句柄
$fh表示一个打开文件的句柄
$h表示一个通用的句柄，其含意有赖于上下文
$rc表示操作代码返回的布什值（真或假）
$rv表示操作代码返回的整数值
$rows表示操作代码返回的行数值
$str表示操作代码返回的字符串
@ary表示查询返回的一行值的数组（列表）
@row_ary表示从查询中返回的一个行的数组
**** 可移植的DBI方法：
connect 建立到一个数据库服务器的连接
disconnect 断开数据库服务器的连接
prepare 准备执行一个SQL语句
execute 执行准备好的语句
do 准备并执行一个SQL语句
quote 加引号于要插入的字符串或BLOB值
fetchrow_array 作为一个字段数组取出下一行
fetchrow_arrayref 作为一个字段的引用数组取出下一行
fetchrow_hashref 作为一个哈希表的引用取出下一行
fetchall_arrayref 作为一个字段数组取出所有数据
finish 完成一条语句并且让系统释放资源
rows 返回受影响的行数
data_sources 返回可在localhost上得到的数据库的数组
ChopBlanks 控制fetchrow_*方法是否剥去空格
NUM_OF_PARAMS 在准备的语句中的占位(placeholder-参数)的数目
NULLABLE 其列可以是NULL
trace 执行调试跟踪
*** perl安装DBD::Oracle模块
DBD::Oracle模块既可安装在有Oracle Database的主机上，
也可以装在没有Oracle Database的主机上，后者需要安装Oracle Instant Client进行远程数据库连接，
需要的Oracle Instant Client；(version 11失败)
instantclient-basic-zip
instantclient-sdk.zip
instantclient-sqlplus.zip
网址：http://www.oracle.com/technetwork/database/features/instant-client/index-097480.html
在windows下要配置PATH:F:\instantclient_12_1;
配置ORACLE_HOME:/tmp/InstantClient/instantclient #??
采用手动的配置方式，

配置完环境变量后要重启工具！！！！！

*** 处理日期和时间模块
最为流行的是Dave Rolsky编写的DateTime模块，
my $dt = DateTime->from_epoch(epoch => time);
print '%4d%02d%02d',$dt->year,$dt->month,$dt->day;
该模块还有格式化输出的时间字符串的方法
print $dt->ymd; #2011-1-2
print $dt->ymd('/'); #2011/05/3

可以通过两个DateTime计算时间间隔
my $dt1 = DateTime->new(
  year => 1987,
  month => 12,
  day => 18,
);
my $dt2 = DateTime->new(
  year => 2011,
  month => 4,
  day => 1,
);
my $duration = $dt2 - $dt1;
my @units = $duration -> in_units(qw(year month day));
printf '%d years, %d month, and %d days',@units;

可以将一个间隔时间加到某一个日期对象上
my $duration = DateTime::Duration->new(day =>5);
my $dt3 = $dt2 + $duration;
print $dt3->ymd; #2011-05-06
*** Time::Piece
my $t = localtime;
print 'The month is '.$t->month ."\n";
*** File::Find::Rule(https://metacpan.org/pod/File::Find::Rule)
use File::Find::Rule;
# find all the subdirectories of a given directory
my $directory = "F:\\wmy";
my @subdirs = File::Find::Rule->directory->in( $directory );

# find all the .pm files in @INC
my @files = File::Find::Rule->file()
                            #->name( '*.pm' )
                            ->name(qr/.*CarouselImage/)
                            ->in( @INC );


# as above, but without method chaining
my $rule =  File::Find::Rule->new;
$rule->file;
$rule->name( '*.pm' );
my @files = $rule->in( @INC );

Specifies names that should match. May be globs or regular expressions.

$set->name( '*.mp3', '*.ogg' ); # mp3s or oggs
$set->name( qr/\.(mp3|ogg)$/ ); # the same as a regex
$set->name( 'foo.bar' );        # just things named foo.bar
*** File::Copy 主要提供了copy和move函数
use File::Copy;
my $filein=$ARGV[0];
my $fileout=$ARGV[1];
copy($filein,$fileout) or die "copy $filein to $fileout failed\n";
move($fileout,"$fileout.test") or die "mv $fileout to $fileout.txt failed\n";
*** File::Path 目录操作 https://metacpan.org/pod/File::Path
# 移除1234目录下的文件
remove_tree('1234',{keep_root => 1});
# 移除1234整个目录
remove_tree('1234');
*** Archive::Zip（https://metacpan.org/pod/Archive::Zip）
#+BEGIN_EXAMPLE perl
use Archive::Zip;
my $zip = Archive::Zip->new();

# add all readable files and directories below . as xyz/*
$zip->addTree( '.', 'xyz' );

# add all readable plain files below /abc as def/*
$zip->addTree( '/abc', 'def', sub { -f && -r } );

# add all .c files below /tmp as stuff/*
$zip->addTreeMatching( '/tmp', 'stuff', '\.c$' );

#add all .o files below /tmp as stuff/* if they aren't writable
$zip->addTreeMatching( '/tmp', 'stuff', '\.o$', sub { ! -w } );

# add all .so files below /tmp that are smaller than 200 bytes as stuff/*
$zip->addTreeMatching( '/tmp', 'stuff', '\.o$', sub { -s < 200 } );

# and write them into a file
$zip->writeToFileNamed('xxx.zip');

# now extract the same files into /tmpx
$zip->extractTree( 'stuff', '/tmpx' );
#+END_EXAMPLE
*** Net::Telnet(https://metacpan.org/pod/Net::Telnet)
use strict;
use UTF8;
use Net::Telnet ();

my $host = "115.159.204.96";
my $user = "ubuntu";
my $pass = "LZgr,,1993";
my $t = new Net::Telnet (Timeout => 20);
$t->open($host);
$t->login($user, $pass);
print $t->cmd('ls');
$t->close;

*** Net::OpenSSH(https://metacpan.org/pod/Net::OpenSSH)

*** 打包perl(https://metacpan.org/pod/pp)
安装 Parse::Binary, Win32::Exe, Module::ScanDeps, PAR::Dist, PAR,PAR::Packer
执行pp -o foo.exe foo.pl
*** Tk(https://metacpan.org/pod/Tk)
用ppm install Tk安装
*** Moose、MooseX::Declare(https://metacpan.org/pod/MooseX::Declare)
使面向对象的开发过程更加简单
*** Win32::OLE（https://metacpan.org/pod/Win32::OLE）
https://msdn.microsoft.com/en-us/library/kw65a0we.aspx

my $test = encode("gbk", decode("utf8", "宋体"));
my $word = CreateObject Win32::OLE 'Word.Application' or die $!;
$word->{'Visible'} = 1;
my $document = $word->Documents->Add;
my ($t_row, $t_col) = (3,3);
my $table = $document->Tables->Add($selection->Range,$t_row, $t_col);
    $table->Select();
    #$table->AutoFormat(1);
#(样式，上下边框，第一行背景色，第一行是否加粗 颜色，线条颜色，倒数第二条线斜体，倒数第二条线，第一条竖线，最后一列头加粗，)
$table->AutoFormat(23,1,1,1,0,0,0,0,0,0);
$table->Cell(1,1)->Range->{Text} = "Blue";
$selection->MoveDown(4,6);
$selection -> TypeText("How do you feel today");
$selection -> TypeText($test);
$selection -> TypeParagraph;
#$document->saveas('C:\\Users\\Admin\\Desktop\\ceshi.doc');
#$word->quit()
** problem
*** 关于perl中文乱码
Perl只认识两种编码: Ascii(octets)和utf8(string)。
perl靠字符串上的utf8 flag 确定一个字符串是octets还是utf8编码的字符串
字符串结构由两部分组成: 数据和utf8 flag.如果utf8 flag是On的话, perl就会把它当成utf8字符串来处理, 如果utf8 flag为Off,
perl就会把它当成octets来处理. 所有字符串相关的函数包括正则表达式都会受utf8 flag的影响.
那么确定一个字符串的utf8 flag是否已开启? 使用Encode::is_utf8($str). 看看它的utf8 flag是否开启.
一、  字符串读入乱码
读入的内容乱码有两种情形：
1.   字符串本来不是utf8编码的, 应该先把它转成utf8编码, 并且使它的utf8 flag处于开启状态. 比如下面将gbk转换成utf8编码。

my $out=decode("gbk",$str);

这里拿我们lwp为例子，原来baidu.com的编码为gbk，转换成utf8后就不乱码了。代码如下：

my $url='http://www.baidu.com';

my $content=get $url;

die "Couldn't get $url" unless defined $content;

my $out=decode("gbk",$content);

print $out,"\n";

2.   字符串编码本来就是utf8, 只是utf8 flag没有打开, 那么你可以使用以下方式中的任一种来开启utf8 flag

$str = Encode::decode_utf8($str);

$str = Encode::decode("utf8", $str);

二、  字符串输出乱码
使用如下代码来将utf8的编码转换成其他的编码：
$str = Encode::encode('charset', $str);
*** Perl UTF8与GBK的转换
不能加use utf8;
use Encode;
gbk转uft-8：
$line = encode("utf-8",decode("gbk",$line));
或
$line = encode_utf8(decode("gbk",$line));
utf-8转gbk：
$line = encode("gbk", decode("utf8", $line));
uft-8转gb2312：
$line = encode("gb2312", decode("utf8", $line));
** website
documentation
http://perldoc.perl.org/

cpan
http://www.cpan.org/
https://metacpan.org/
http://search.cpan.org

community
http:://www.stackoverflow.com
http://www.perlmonks.org
http://learn.perl.org/
* Java
** basic
*** 堆内存和栈内存
Java的堆内存是一个运行时数据区，用以保存类的实例（对象）
Java虚拟机的堆内存中存储着正在运行的应用程序所建立的所有对象。

一个方法执行时，该方法会建立自己的内存栈，方法内的变量也会放入这块栈内存里，方法执行结束，内存栈也将自然销毁。
类也是引用数据类型，程序中定义的Person类型的变量实际上是一个引用，存放在栈内存中。
实际上Java的引用就是C里的指针。Java中没有指针

内存中的数组
实际的数组对象被存储在堆内存中，如果引用该数组对象的数组引用变量是一个局部变量，那么它（数组引用变量）被存储在栈内存中。
*** 接口和抽象类的区别
接口和抽象类的概念不一样。接口是对动作的抽象，抽象类是对根源的抽象。
抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。比如，男人，女人，这两个类（如果是类的话……），他们的抽象类是人。说明，他们都是人。
人可以吃东西，狗也可以吃东西，你可以把“吃东西”定义成一个接口，然后让这些类去实现它.
所以，在高级语言上，一个类只能继承一个类（抽象类）(正如人不可能同时是生物和非生物)，但是可以实现多个接口(吃饭接口、走路接口)。
第一点． 接口是抽象类的变体，接口中所有的方法都是抽象的。而抽象类是声明方法的存在而不去实现它的类。
第二点． 接口可以多继承，抽象类不行
第三点． 接口定义方法，不能实现，而抽象类可以实现部分方法。
第四点． 接口中基本数据类型为static 而抽类象不是的。
当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。

抽象类的功能要远超过接口，但是，定义抽象类的代价高。因为高级语言来说（从实际设计上来说也是）每个类只能继承一个类。在这个类中，你必须继承或编写出其所有子类的
所有共性。虽然接口在功能上会弱化许多，但是它只是针对一个动作的描述。而且你可以在一个类中同时实现多个接口。在设计阶段会降低难度的。
*** 集合
**** List Set Map
Set 元素不能重复,加入Set的元素必须定义equals()方法以确保对象的唯一性，Set和Conllection有完全一样的接口
HashSet：是最快的获取元素方式，没有存储顺序，存入HashSet的元素必须定义hashCode();
TreeSet：生成一个总是处于排序状态的Set，元素必须实现Comparable接口，迭代比HashSet快。
LinkedHashSet：按照被添加的顺序保存对象（链表方式），具有HashSet的查询速度，插入元素必须定义hashCode()，插入操作比HashSet代价更高，由于维护链表所带来额外开销造成的。
SortedSet：的意思是“按对象的比较函数对元素排序”，进一步提供关于元素的总体排序 的Set。这些元素使用其自然mp顺序进行排序，或者根据通常在创建有序 set 时提供的Comparator 进行排序。

HashMap：提供最快的查找技术，插入和查询“键值对”的开销是固定的，可以通过构造器设置容量和负载因子，以调整性能
TreeMap： 基于红黑树实现，查看“键”或“键值对”时，他们会被排序（次序由Compatable或Comparator决定）。TreeMap是唯一带有subMap()方法的Map，它可以返回一个子树。
LinkedHashMap：  类似于HashMap,但是迭代遍历它时，取得“键值对”的顺序时其插入次序，或者时最近最少使用的次序（这种映射很适合构建 LRU 缓存），只是比HashMap慢一点，而在迭代访问时反而更快，因为使用链表维护内部次序。
WeakHashMap：弱键映射，允许释放映射所指向的对象。如果映射之外没有引用指向某个“键”，则此“键”可以被垃圾收集器回收。
IdentityHashMap：使用==代替equals()对“键”进行比较的散列映射，
ConcurrentHashMap：一种线程安全的Map。
SortedMap：TreeMap是现阶段的唯一实现，可以确保键处于排序状态。

List以特定顺序保存一组元素
ArrayList：用于随机访问元素，但在List中插入和移除元素时较慢，底层由数组支持。
LinkedList：通过代价较低的在List中间进行插入和删除操作，提供了优化的顺序访问，在随机访问方面相对较慢，但是特性集比ArrayList更大，底层由双向链表实现。

Queue只允许在容器的一“端”插入对象，另外一端移除对象。在J2SE5中仅有的两个实现是LinkedList和PriorityQueue.    

Deque:一个线性 collection，支持在两端插入和移除元素。
*** static
java编程思想：当声明一个事物是static时，就意味着这个域或方法不会与包含的那个类的任何对象实例关联在一起，
对于static方法，不能简单地通过调用其它非static域或方法而没有指定某个命名对象，来直接访问非static域或方法。普通方法可以直接使用static域或方法。
使用类名是引用static变量的首选方式。
static的真正作用用于区分Field、方法、内部类、初始化块这四种成员到底属于类本身还是属于实例。在类中定义的成员，有static修饰的成员属于类本身，否则属于该类的实例。
使用static修饰的field和方法也称为类Field、类方法
不使用static修饰的field和方法也称为实例field和实例方法
当通过对象来访问类field时，系统会在底层转化为通过该类来访问类field。
null对象可以访问它所属类的类成员。。
类成员不能访问实例成员，类成员的作用域比实例成员的作用域大。
*** 构造器
构造器有没有返回值

实际上构造器是有返回值的，用new关键字来调用构造器时，构造器返回该类的实例，，因此构造器的返回值总是当前类。
构造器是创建Java对象的重要途径

通过new调用构造器时，构造器确实返回了该类的对象，但这个对象并不是完全由构造器负责创建。调用构造器时，系统先为该对象分配内存空间，并执行默认初始化，这个对象已经产生了，这些操作在构造器执行之前就都完成了。构造器执行体执行结束后，这个对象作为构造器的返回值返回。

Java的子类不能获得父类的构造器
*** 重写
重写要遵循“两同，两小，一大”规则。
“两同”：方法名相同、形参列表相同。
“两小”：子类方法返回值类型比父类更小或相等、子类方法声明抛出的异常类。。同前。。
“一大”：访问权限比父类大

如果需要在子类中调用父类中被覆盖的方法，则可以使用super（被覆盖的是实例方法）或者父类类名（被覆盖的是类方法）。
*** 设计父类通常遵循的规则
1、尽量隐藏父类的内部数据。尽量把所有的Field都设置成private。
2、不要让子类可以随意访问和修改父类的方法。父类中仅为辅助其他的工具方法，应该使用private修饰，让子类无法访问；如果父类中的方法需要被外部类调用，则必须以public修饰，但又不希望子类重写该方法，可以使用final修饰符；如果希望父类的某个方法被子类重写，但不希望被其他类自由访问，则可以使用protected
3、尽量不要在父类构造器中调用将要被重写的方法
*** 对象的软、弱和虚引用
软引用（SoftReference）：当系统内存空间足够时，它不会被系统回收，当系统内存不足时，系统才会回收它。软引用通常用于对内存敏感的程序中。
弱引用（WeakReference）：当系统垃圾回收机制运行时，总会回收该对象占用的内存。
虚引用（PhantomReference）：虚引用主要用于跟踪对象被垃圾回收的状态，虚引用不能单独使用，虚引用必须和引用队列联合使用。
*** this关键字
编译器会暗自把“所操作对象的引用”作为第一个参数传递给方法。this关键词只能在方法内部使用，表示对“调用方法的那个对象”的引用。this的用法和其他对象引用并无不同。

如果在方法内部调用同一类的另一个方法，不必使用this，直接调用即可。当方法需要返回当前对象的引用时才需要明确使用this，如需要返回当前对象时。

如果要将当前对象传递给外部的方法，this关键词就很有用。

可能为一个类写了多个构造器，想在一个构造其中调用另一个构造器，以避免重复代码。this关键字可以做到这一点。

尽管可以用this调用一个构造器，但不能调用两个。此外，必须将构造器置于最起始处，否则编译器会报错。

除了构造器外，编译器禁止在其他任何地方调用构造器。

static方法是属于类的，所以里面不能用this关键字。
*** 类字面常量
java还提供了另一种方法来生成对Class对象的引用，即使用类字面常量。如：
FancyToy.class;

这样做不仅简单，而且更安全，因为它是在编译时候就会受到检查（因此不需要置于try语句块中），并且它根除了对forName()方法的调用，所以也更高效。

类字面常量不仅可以应用于普通的类，也可以应用于接口、数组、以及基本数据类型。另外，对于基本数据类型的包装类，还有一个标准的TYPE。TYPE字段是一个引用，指向对应的基本数据类型的Class对象，和.class是等效的。

当使用.class来创建对Class对象的引用的时候，不会自动初始化该Class对象，为了使用类而做的准备工作实际包含三个步骤：

加载。由类加载器执行。该步骤将查找字节码，并从字节码中创建class对象。
链接。验证类中的字节码，为静态域分配存储空间，并且需要的话，将解析这个类创建的对其他类的所有引用。
初始化。如果该类具有超类，则对其进行初始化，执行静态初始化器和静态初始化模块。
仅使用.class语法来获得对类的引用不会引发初始化。但是，为了产生Class引用，Class.forName()立即就进行了初始化。
如果一个static final值是“编译期常量”，那么这个值不需要对类进行初始化就可以被读取。但是有例外，如果是通过一个静态方法赋值的，仍需要进行初始化。
如果是一个static域不是final，对它进行访问时，总是要求在它被读取之前，要先进行链接和初始化。

*** 使用内省api得到bean属性
内省访问JavaBean属性的两种方式：
第一种：
通过PropertyDescriptor类操作Bean的属性
通过Introspector类获得Bean对象的 BeanInfo，
然后通过 BeanInfo 来获取属性的描述器（ PropertyDescriptor ），
通过这个属性描述器就可以获取某个属性对应的 getter/setter 方法，
然后通过反射机制来调用这些方法。
例：
Student sd=new Student();
       BeanInfo bif=Introspector.getBeanInfo(Student.class);
       PropertyDescriptor pdrs[]=bif.getPropertyDescriptors();
       for (PropertyDescriptor pd : pdrs) {
           if (pd.getName().equals("age")) {
              Method md = pd.getWriteMethod();
              md.invoke(sd, 12);
           }
       }
    //简便的方法
    @Test
    public void test1()throws Exception{
       Student st = new Student();
       //通过构造器 创建 PropertyDescriptor对象
PropertyDescriptor pd=newPropertyDescriptor("age",Student.class);
       Method md = pd.getWriteMethod(); //写操作
       md.invoke(st, 120);
       System.out.println(st.getAge());
       md = pd.getReadMethod();
       int value = (Integer)md.invoke(st, null); //读操作
       System.out.println(value);
     第二种：beanutils工具包
Sun公司的内省API过于繁琐，所以Apache组织结合很多实际开发中的应用场景开发了一套简单、易用的API操作Bean的属性――BeanUtils
Beanutils工具包的常用类：
-        BeanUtils
-        PropertyUtils
-        ConvertUtils.regsiter(Converter convert, Class clazz)
-        自定义转换器
例：采用BeanUtils为Student类的name属性赋值
   @Test
    public void test1() throws Exception {
       // 1、加载Class文件
    Classcls = Class.forName("cn.csdn.beanutils.Student");
       // 2、创建bean对象
       Student bean = (Student) cls.newInstance();
       // 3、采用BeanUtils对name属性赋值
       BeanUtils.setProperty(bean, "name", "xxx");
       String value = BeanUtils.getProperty(bean, "name");
       System.out.println(value);
    }
例：Beanutils支持基本数据类型的自动转换
    @Test
    public void test2() throws Exception {
       // 1、定义class文件
Stringclass Name="cn.csdn.beanutils.Student";
       // 2、定义操作的属性
       String name = "age";
       // 3、创建class对象
       Class cls = Class.forName(className);
       // 4、创建bean对象
       Student bean = (Student) cls.newInstance();
       // 5、为操作的bean对象的name属性赋值
       BeanUtils.setProperty(bean, name, "200");
       // 6、执行输出
       System.out.println(bean.getAge());
    }
 
    @Test
    public void test3() throws Exception{
       Student st = new Student();
           BeanUtils.setProperty(st, "name", "redarmy"); // 避免了基本的数据类型转换的问题
       System.out.println(st.getName());
    }
   @Test
    public void test4() throws Exception {
       Student bean = new Student();
       BeanUtils.setProperty(bean, "birthday", new Date());
       System.out.println(bean.getBirthday());
    }
*** 类加载器
在java中一个类用其全限定类名（包括包名和类名）作为标识
在JVM中，一个类用全限定类名和其类加载器作为唯一标识

当JVM启动时，会形成由3个类加载器组成的初始类加载器层次结构。
Bootstrap ClassLoader：根类加载器
Extension ClassLoader：扩展类加载器
System ClassLoader：系统类加载器

根类加载器负责加载java的核心类，根类加载器不是java.lang.ClassLoader的子类，而是由JVM自身实现的，

扩展类加载器负责加载JRE的扩展目录（%JAVA_HOME%/jre/lib/ext或者由java.ext.dirs系统属性指定的目录）中JAR包的类，
通过这种方式就可以为java扩展核心类以外的新功能，只需要把自己开发的类打包成JAR文件放入JAVA_HOME%/jre/lib/ext路径即可。

系统加载器负责在JVM启动时加载来自java命令的-classpath选项。java.class.path系统属性，或者CLASSPATH环境变量所指定的JAR包和类路径，
程序通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器，系统加载器的加载路径是程序运行的当前路径，

扩展类加载器的父类加载器是根类加载器，根类加载器不是java实现的，

*** 类加载、类连接、类初始化。
初始化及类的加载

类的代码在初次使用时才加载。这通常是指加载发生于创建类的第一个对象之时，但是当访问static域或static方法时，也会发生加载。（构造器也是static的，类是在任何static成员被访问时被加载的）。所有的static对象和static代码段都会在加载时依定义类时的书写顺序而依次初始化的。当然定义为static的东西只会被加载一次。

加载类的基类，如果基类还有基类，则继续加载，如此类推。其它任何事物发生之前，将分配给对象的存储空间初始化成二进制的零。
根基类中的static初始化(static域和static块初始化)，然后下个导出类，以此类推。
根基类初始化：非static显示初始化，调用构造器。
导出类初始化，流程与基类类似。

类加载指的是将类的class文件读入内存，并为之创建一个java.lang.Class对象。
当程序主动使用某个类时，如果该类未被加载到内存中，则系统会通过加载、连接、初始化来对类进行初始化。
类的加载由类加载器完成，类加载器由JVM提供。开发者可以通过继承ClassLoader基类来创建自己的类加载器。
可以预先加载某些类，无须等到首次使用


系统生成对应的Class对象后，进入连接阶段，负责把类的二进制数据合并到JRE中，类连接又可以分为三个阶段
1）验证：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。
2）准备：类准备阶段则负责为类的静态Field分配内存，并设置默认初始值，
3）解析：将类的二进制数据中的符号引用替换成直接引用。

在类初始化阶段，虚拟机负责对类进行初始化，主要是对静态Filed进行初始化，

类初始化的时机：
1）创建类的实例
2）调用某个类的静态方法
3）访问某个类或接口的静态Field，或为该静态Fidld赋值，
4）使用反射方式强制创建某个类或接口对应的java.lang.Class对象，例如Class.forName("Person");
5）初始化某个类的子类
6）直接使用java.exe命令来运行某个主类。

如果final型的静态field的值在编译时就确定下来，那么这个Field就相当于宏变量，即使程序使用该静态Field也不会导致该类的初始化。

*** 对象在内存中的状态
可达状态：对一个对象被创建后，若有变量引用它，则这个对象在程序中处于可达状态。
可恢复状态：程序中某个对象不再有任何引用变量引用它，就进入了可恢复状态，在这种状态下，垃圾回收机制准备回收该对象所占用的内存，
在回收该对象之前，系统会调用所有课恢复状态对象的finalize()方法进行资源清理。
不可达状态：系统已经调用所有对象的finalize()方法后依然没有使该对象变成可达状态，那么这个对象变成不可达状态。只有当对象处于不可达状态时，系统才会真正回收该对象所占有的资源。
*** final
最好根据设计来决定是否使用final，而不是出于试图提高性能的目的来使用final。

final数据
public static final int VALUE_THREE=99;
定义为public，则可以被用于包之外，
定义为static，则强调只有一份，
定义为final，则说明它是一个常量，

public class FinalData{
final int i2 = rand.nextInt(20);
static final int INT_3 = rand.newInt(20);
public static void main(String[]  args){
FinalData fd = new FilalData();
}
}
i2的值是唯一的，但INT_3的值是不可以通过创建第二个FinalData对象而加以改变。
这是因为它是static，在装载时已被初始化，而不是每次创建新对象时都初始化。

“空白final”在final的使用上提供了更大的灵活性，一个类中的final域就可以做到根据对象而有所不同，却又保持其很定不变的特性。
必须在域的定义处或者每个构造器中用表达式对final赋值，可以保证final域在使用前总是被初始话。    

按照惯例，既是static又是final的域（即编译时常量）,将用大写表示，并使用下划线分隔各个单词，

如果final修饰的局部变量在定义时没有指定默认值，在后面可以赋初始值，但只能一次。

final修饰引用类型时，它保存的仅仅是个引用，final只保证这个引用类型变量所引用的地址不会改变，但这个对象可以发生改变。引用变量不能被重新赋值，但可以改变引用对象的内容。

final方法
使用final方法有两个原因   ： 第一个原因是把方法锁定，以防止任何继承类修改它的含义。
这是出于设计的考虑：想要确保在继承中使方法行为保持不变，并且不会被覆盖。
但更重要的一点可能是或许是：这样做可以有效的“关闭”动态绑定，这样，编译器就可以为final方法调用生成更有效的代码。
过去建议使用final方法  第二个原因是效率。在Java SE5以上应该让编译器和JVM考虑效率问题，
只有出于防止覆盖时，使用final。所有private方法都隐式指定为final的。由于无法取用private方法，
因此也就无法覆盖它。但是当你试图覆盖一个private方法时似乎是有效的，“覆盖”，只有在某方法是某类接口的一部分时才会出现。
如果某方法是private，它就不是基类的接口的一部分。它仅是一些隐藏于类中的程序代码，只不是具有相同名称而已。
但如果导出类以相同名称生成一个public、protected或包访问权限方法的话，此时你并没有覆盖该方法，仅是生成了一个新方法。

final参数
这意味着你无法在方法中更改参数引用所指向的对象，这一特性主要用来向匿名内部类传递数据。

不能对final修饰的形参赋值，系统根据传入的参数来完成初始化。

final类

当你不打算继承某类，而且也不允许别人这么做的时候，可以将一个类定义为final的。不论类是否为final的，
相同的规则都适用于定义为final的域。然而，final类中所有方法都隐式指定为final的，因为无法覆盖它们。



final修饰符的一个重要用途就是定义“宏变量”。定义final变量时制定了初始值，该初始值可以在编译时就确定下来，
那么这个final变量本质上就是一个“宏变量”，编译器会把所有用到该变量的额地方直接替换成该变量的值。

String s1 = "ab";
String str1 = "a";
String str2 = "b";
String s3 = str1+str2;
s1==s3为false；
str1和str2只是普通变量，不会执行“宏替换”，所以编译器在编译时不能确定s3的值，也就无法让s3指向字符串池中缓存的“ab”。
** Effective Java
*** Creating and Destroying Objects(创建和销毁对象)
**** Item 1: Consider static factory methods instead of constructors（用静态工厂方法代替构造器）
#+BEGIN_SRC java
public static Boolean valueOf(boolean b) {
  return b ? Boolean.TRUE : Boolean.FALSE;
}
#+END_SRC

*One advantage of static factory methods is that, unlike constructors, they have names.*

*A second advantage of static factory methods is that, unlike constructors,
they are not required to create a new object each time they’re invoked.*

*A third advantage of static factory methods is that, unlike constructors,
they can return an object of any subtype of their return type.*

*A fourth advantage of static factory methods is that they reduce the verbosity of creating parameterized type instances.*
#+BEGIN_SRC java
public static <K, V> HashMap<K, V> newInstance() {
  return new HashMap<K, V>();
}
Map<String, List<String>> m = HashMap.newInstance()
#+END_SRC
*The main disadvantage of providing only static factory methods is that
classes without public or protected constructors cannot be subclassed.*

*A second disadvantage of static factory methods is that they are not
readily distinguishable from other static methods.*

**** Here are some common names for static factory methods:
? valueOf―Returns an instance that has, loosely speaking, the same value as its
parameters. Such static factories are effectively type-conversion methods.
? of―A concise alternative to valueOf, popularized by EnumSet (Item 32).
? getInstance―Returns an instance that is described by the parameters but
cannot be said to have the same value. In the case of a singleton, getInstance
takes no parameters and returns the sole instance.
? newInstance―Like getInstance, except that newInstance guarantees that
each instance returned is distinct from all others.
? getType―Like getInstance, but used when the factory method is in a different class. Type indicates the type of object returned by the factory method.
? newType―Like newInstance, but used when the factory method is in a different class. Type indicates the type of object returned by the factory method.
**** Item 2: Consider a builder when faced with many constructor parameters（遇到多个构造器参数时考虑用构建器）
the telescoping constructor pattern works, but it is hard to write client code when there are many parameters, and harder still to read it
a JavaBean may be in an inconsistent state partway through its construction

the Builder pattern is a good choice when designing classes whose constructors or static factories would have more than a handful of parameters
#+BEGIN_SRC java

NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8).
calories(100).sodium(35).carbohydrate(27).build();

// Builder Pattern
public class NutritionFacts {
    private final int servingSize;
    private final int servings;
    private final int calories;
    private final int fat;
    private final int sodium;
    private final int carbohydrate;
    public static class Builder {
        // Required parameters
        private final int servingSize;
        private final int servings;
        // Optional parameters - initialized to default values
        private int calories = 0;
        private int fat = 0;
        private int carbohydrate = 0;
        private int sodium = 0;
        public Builder(int servingSize, int servings) {
            this.servingSize = servingSize;
            this.servings = servings;
        }
        public Builder calories(int val)
            { calories = val; return this; }
        public Builder fat(int val)
            { fat = val; return this; }
        public Builder carbohydrate(int val)
            { carbohydrate = val; return this; }
        public Builder sodium(int val)
            { sodium = val; return this; }
        public NutritionFacts build() {
            return new NutritionFacts(this);
        }
    }
    private NutritionFacts(Builder builder) {
        servingSize = builder.servingSize;
        servings = builder.servings;
        calories = builder.calories;
        fat = builder.fat;
        sodium = builder.sodium;
        carbohydrate = builder.carbohydrate;
    }
}

#+END_SRC
**** Item 3: Enforce the singleton property with a private constructor or an enum type(用私有构造器或枚举类型强化单例属性)
A singleton is simply a class that is instantiated exactly once
*In one approach, the member is a final field:*
#+BEGIN_SRC java

// Singleton with public final field
public class Elvis {
    public static final Elvis INSTANCE = new Elvis();
    private Elvis() { ... }
    public void leaveTheBuilding() { ... }
}
#+END_SRC
with one caveat: a privileged client can invoke the private constructor reflectively
(Item 53) with the aid of the AccessibleObject.setAccessible method. If you
need to defend against this attack, modify the constructor to make it throw an
exception if it’s asked to create a second instance.

*In the second approach to implementing singletons, the public member is a static factory method:*
#+BEGIN_SRC java
// Singleton with static factory
public class Elvis {
    private static final Elvis INSTANCE = new Elvis();
    private Elvis() { ... }
    public static Elvis getInstance() { return INSTANCE; }
    public void leaveTheBuilding() { ... }
}
#+END_SRC
The main advantage of the public field approach is that the declarations make
it clear that the class is a singleton: the public static field is final, so it will always
contain the same object reference. There is no longer any performance advantage
to the public field approach

*there is a third approach to implementing singletons. Simply make an enum type with one element:*
#+BEGIN_SRC java
// Enum singleton - the preferred approach
public enum Elvis {
    INSTANCE;
    public void leaveTheBuilding() { ... }
}
#+END_SRC
This approach is functionally equivalent to the public field approach, except that it
is more concise, provides the serialization machinery for free, and provides an
ironclad guarantee against multiple instantiation, even in the face of sophisticated
serialization or reflection attacks. While this approach has yet to be widely adopted, 
*a single-element enum type is the best way to implement a singleton.*

**** Item 4: Enforce noninstantiability with a private constructor(通过私有构造器强化不可实例化的能力)
a class can be made noninstantiable by including a private constructor:

#+BEGIN_SRC java

// Noninstantiable utility class
public class UtilityClass {
    // Suppress default constructor for noninstantiability
    private UtilityClass() {
        throw new AssertionError();
    }
    ... // Remainder omitted
}

#+END_SRC
**** Item 5: Avoid creating unnecessary objects(避免创建不必要的对象)
the static factory method Boolean.valueOf(String) is preferable to the constructor Boolean(String).

#+BEGIN_SRC java

public class Person {
    private final Date birthDate;
    // Other fields, methods, and constructor omitted
    // DON'T DO THIS!
    public boolean isBabyBoomer() {
        // Unnecessary allocation of expensive object
        Calendar gmtCal =
            Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        gmtCal.set(1946, Calendar.JANUARY, 1, 0, 0, 0);
        Date boomStart = gmtCal.getTime();
        gmtCal.set(1965, Calendar.JANUARY, 1, 0, 0, 0);
        Date boomEnd = gmtCal.getTime();
        return birthDate.compareTo(boomStart) >= 0 &&
            birthDate.compareTo(boomEnd) < 0;
    }
}

//The improved version of the Person class creates Calendar, TimeZone, and Date instances only once, 
=>
class Person {
    private final Date birthDate;
    // Other fields, methods, and constructor omitted
    /**
     * The starting and ending dates of the baby boom.
     */
    private static final Date BOOM_START;
    private static final Date BOOM_END;
    static {
        Calendar gmtCal =
            Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        gmtCal.set(1946, Calendar.JANUARY, 1, 0, 0, 0);
        BOOM_START = gmtCal.getTime();
        gmtCal.set(1965, Calendar.JANUARY, 1, 0, 0, 0);
        BOOM_END = gmtCal.getTime();
    }
    public boolean isBabyBoomer() {
        return birthDate.compareTo(BOOM_START) >= 0 &&
            birthDate.compareTo(BOOM_END) < 0;
    }
}
#+END_SRC

The lesson is clear: *prefer primitives to boxed primitives, and watch out for unintentional autoboxing.*

Conversely, avoiding object creation by maintaining your own object pool is a
bad idea unless the objects in the pool are extremely heavyweight. 
*The classic example of an object that does justify an object pool is a database connection.* 
The cost of establishing the connection is sufficiently high that it makes sense to reuse these objects.
**** Item 6: Eliminate obsolete object references（消除过期的对象引用）

read originaltext

Consider the following simple stack implementation:
#+BEGIN_SRC java
// Can you spot the "memory leak"?
public class Stack {
    private Object[] elements;
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;
    public Stack() {
        elements = new Object[DEFAULT_INITIAL_CAPACITY];
    }
    public void push(Object e) {
        ensureCapacity();
        elements[size++] = e;
    }
    public Object pop() {
        if (size == 0)
            throw new EmptyStackException();
        return elements[--size];
    }
    /**
     * Ensure space for at least one more element, roughly
     * doubling the capacity each time the array needs to grow.
     */
    private void ensureCapacity() {
        if (elements.length == size)
            elements = Arrays.copyOf(elements, 2 * size + 1);
    }
}
#+END_SRC
the program has a "memory leak,"
 If a stack grows and then shrinks, the objects that were popped off the stack will not be garbage collected, even if the program
using the stack has no more references to them. This is because the stack maintains obsolete references to these objects.

The fix for this sort of problem is simple: null out references once they
become obsolete. In the case of our Stack class, the reference to an item becomes
obsolete as soon as it’s popped off the stack. The corrected version of the pop
method looks like this:
#+BEGIN_SRC java

public Object pop() {
    if (size == 0)
        throw new EmptyStackException();
    Object result = elements[--size];
    elements[size] = null; // Eliminate obsolete reference
    return result;
}
#+END_SRC

An added benefit of nulling out obsolete references is that, if they are subsequently dereferenced by mistake, the program will immediately fail with a
NullPointerException, rather than quietly doing the wrong thing. It is always beneficial to detect programming errors as quickly as possible.

What aspect of the Stack class makes it susceptible to memory leaks? Simply put, it manages its own memory.
The storage pool consists of the elements of the elements array (the object reference cells, not the objects themselves).

*Nulling out object references should be the exception rather than the norm.*
*whenever a class manages its own memory, the programmer should be alert for memory leaks.*
*Another common source of memory leaks is caches.*
The LinkedHashMap class facilitates the latter approach with its removeEldestEntry method. 
For more sophisticated caches, you may need to use java.lang.ref directly.

*A third common source of memory leaks is listeners and other callbacks.*
The best way to ensure that callbacks are garbage collected promptly is to store only weak references to them, 
for instance, by storing them only as keys in a WeakHashMap.
**** Item 7: Avoid finalizers（避免使用终结方法）
read again

*Finalizers are unpredictable, often dangerous, and generally unnecessary.*
One shortcoming of finalizers is that there is no guarantee they’ll be executed promptly,
It can take arbitrarily long between the time that an object
becomes unreachable and the time that its finalizer is executed. This means that
you should never do anything time-critical in a finalizer. 

As a consequence, *you should never depend on a finalizer to update critical persistent state.*
For example, depending on a finalizer to release a persistent lock on a shared resource
such as a database is a good way to bring your entire distributed system to a grinding halt.

and one more thing: *there is a severe performance penalty for using finalizers.*
*** Methods Common to All Objects(对所有对象都通用的方法)
**** 
** code
*** excel导出
#+BEGIN_SRC java
import java.io.IOException;
import java.io.OutputStream;
import java.util.List;
import javax.servlet.http.HttpServletResponse;
import org.apache.poi.hssf.usermodel.HSSFCell;
import org.apache.poi.hssf.usermodel.HSSFCellStyle;
import org.apache.poi.hssf.usermodel.HSSFFont;
import org.apache.poi.hssf.usermodel.HSSFHeader;
import org.apache.poi.hssf.usermodel.HSSFRow;
import org.apache.poi.hssf.usermodel.HSSFSheet;
import org.apache.poi.hssf.usermodel.HSSFWorkbook;
import org.apache.struts2.ServletActionContext;
    public String export()throws Exception
    {
        List studentList=new ArrayList<Student>();//学生LIst

        for(int i=0;i<10;i++)
        {   Student student=new Student();//学生对象
            student.setStudentId("200908110"+i);
            student.setStudentName("杨波"+i);
            student.setStudentSex("男");
            student.setStudentDormitory("14-20"+i);
            student.setStudentSept("软件工程系");
            studentList.add(student);
        }

        String []tableHeader={"学号","姓名","性别","寝室号","所在系"};

short cellNumber=(short)tableHeader.length;//表的列数
        HSSFWorkbook workbook = new HSSFWorkbook();   //创建一个excel
        HSSFCell cell = null;                                    //Excel的列
        HSSFRow row = null;                                      //Excel的行
        HSSFCellStyle style = workbook.createCellStyle();        //设置表头的类型
        style.setAlignment(HSSFCellStyle.ALIGN_CENTER);
        HSSFCellStyle style1 = workbook.createCellStyle();       //设置数据类型
        style1.setAlignment(HSSFCellStyle.ALIGN_CENTER);
        HSSFFont font = workbook.createFont();                 //设置字体
        HSSFSheet sheet = workbook.createSheet("sheet1");        //创建一个sheet
        HSSFHeader header = sheet.getHeader();//设置sheet的头
try {
            if(studentList.size() < 1 ){
                header.setCenter("查无资料");
            }else{
                header.setCenter("学生表");
                row = sheet.createRow(0);
                row.setHeight((short)400);
                for(int k = 0;k < cellNumber;k++){
                    cell = row.createCell(k);//创建第0行第k列
                    cell.setCellValue(tableHeader[k]);//设置第0行第k列的值
                    sheet.setColumnWidth(k,8000);//设置列的宽度
                    font.setColor(HSSFFont.COLOR_NORMAL);      // 设置单元格字体的颜色.
                    font.setFontHeight((short)350); //设置单元字体高度
                    style1.setFont(font);//设置字体风格
                    cell.setCellStyle(style1);
                }

                for(int i = 0 ;i < studentList.size() ;i++){
                    Student student1 = (Student)studentList.get(i);//获取student对象
                    row = sheet.createRow((short) (i + 1));//创建第i+1行
                    row.setHeight((short)400);//设置行高

                    if(student1.getStudentId() != null){
                         cell = row.createCell(0);//创建第i+1行第0列
                         cell.setCellValue(student1.getStudentId());//设置第i+1行第0列的值
                cell.setCellStyle(style);//设置风格
                    }
                    if(student1.getStudentName() != null){
                         cell = row.createCell(1); //创建第i+1行第1列

                         cell.setCellValue(student1.getStudentName());//设置第i+1行第1列的值

                         cell.setCellStyle(style); //设置风格
                    }
//由于下面的和上面的基本相同，就不加注释了
                    if(student1.getStudentSex() != null){
                         cell = row.createCell(2);
                         cell.setCellValue(student1.getStudentSex());
                         cell.setCellStyle(style);
                    }
                    if(student1.getStudentDormitory()!= null){
                         cell = row.createCell(3);
                         cell.setCellValue(student1.getStudentDormitory());
                         cell.setCellStyle(style);
                    }
                    if(student1.getStudentSept() != null){
                         cell = row.createCell(4);
                         cell.setCellValue(student1.getStudentSept());
                         cell.setCellStyle(style);
                    }

                }

            }

        } catch (Exception e) {
            e.printStackTrace();
        }


        HttpServletResponse response = null;//创建一个HttpServletResponse对象
        OutputStream out = null;//创建一个输出流对象
        try {
            response = ServletActionContext.getResponse();//初始化HttpServletResponse对象
            out = response.getOutputStream();//

    StringheaderStr ="student学生";
    headerStr =new String(headerStr.getBytes("gb2312"), "ISO8859-1");//headerString为中文时转码
    response.setHeader("Content-disposition","attachment; filename="+    headerStr+".xls");//filename是下载的xls的名，建议最好用英文
            response.setContentType("application/msexcel;charset=UTF-8");//设置类型
            response.setHeader("Pragma","No-cache");//设置头
            response.setHeader("Cache-Control","no-cache");//设置头
            response.setDateHeader("Expires", 0);//设置日期头
            workbook.write(out);
            out.flush();
            workbook.write(out);
        } catch (IOException e) {
            e.printStackTrace();
        }finally{
            try{

                if(out!=null){
                    out.close();
                }

            }catch(IOException e){
                e.printStackTrace();
            }

        }

        return null;
   }
#+END_SRC
注：最好返回null,否则有可能报错
*** excel导入
ExcelUtil.exportListFromExcel(path,excelFileFileName, 0);
public class ExcelUtil {
        /**
     * Excel 2003
     */
    private final static String XLS = "xls";
    /**
     * Excel 2007
     */
    private final static String XLSX = "xlsx";
    /**
     * 分隔符
     */
    private final static String SEPARATOR = "|";


    /**
     * 由Excel流的Sheet导出至List
     *
     * @param is
     * @param extensionName
     * @param sheetNum
     * @return
     * @throws IOException
     */
    public static List<String> exportListFromExcel(String path,
            String extensionName, int sheetNum) throws IOException {

        Workbook workbook = null;
        if (extensionName.toLowerCase().endsWith(XLS)) {
            workbook = new HSSFWorkbook(new FileInputStream(new File(path)));
        } else if (extensionName.toLowerCase().endsWith(XLSX)) {
            workbook = new XSSFWorkbook(new FileInputStream(new File(path)));
        }
        return exportListFromExcel(workbook, sheetNum);
    }

    /**
     * 由指定的Sheet导出至List
     *
     * @param workbook
     * @param sheetNum
     * @return
     * @throws IOException
     */
    private static List<String> exportListFromExcel(Workbook workbook,
            int sheetNum) {

        Sheet sheet = workbook.getSheetAt(sheetNum);

        // 解析公式结果
        FormulaEvaluator evaluator = workbook.getCreationHelper()
                .createFormulaEvaluator();

        List<String> list = new ArrayList<String>();

        int minRowIx = sheet.getFirstRowNum();
        int maxRowIx = sheet.getLastRowNum();
        for (int rowIx = minRowIx; rowIx <= maxRowIx; rowIx++) {
            Row row = sheet.getRow(rowIx);
            StringBuilder sb = new StringBuilder();

            short minColIx = row.getFirstCellNum();
            short maxColIx = row.getLastCellNum();
            for (short colIx = minColIx; colIx <= maxColIx; colIx++) {
                Cell cell = row.getCell(new Integer(colIx));
                CellValue cellValue = evaluator.evaluate(cell);
                if (cellValue == null) {
                    continue;
                }
                // 经过公式解析，最后只存在Boolean、Numeric和String三种数据类型，此外就是Error了
                // 其余数据类型，根据官方文档，完全可以忽略http://poi.apache.org/spreadsheet/eval.html
                switch (cellValue.getCellType()) {
                case Cell.CELL_TYPE_BOOLEAN:
                    sb.append(SEPARATOR + cellValue.getBooleanValue());
                    break;
                case Cell.CELL_TYPE_NUMERIC:
                    // 这里的日期类型会被转换为数字类型，需要判别后区分处理
                    if (DateUtil.isCellDateFormatted(cell)) {
                        sb.append(SEPARATOR + cell.getDateCellValue());
                    } else {
                        sb.append(SEPARATOR + cellValue.getNumberValue());
                    }
                    break;
                case Cell.CELL_TYPE_STRING:
                    sb.append(SEPARATOR + cellValue.getStringValue());
                    break;
                case Cell.CELL_TYPE_FORMULA:
                    break;
                case Cell.CELL_TYPE_BLANK:
                    break;
                case Cell.CELL_TYPE_ERROR:
                    break;
                default:
                    break;
                }
            }
            list.add(sb.toString());
        }
        return list;
    }
}
*** ajaxupload.js上传图片
**** js代码（需要导入ajaxupload.js）
// 删除图片
$('#btn_close').click(function(){

        var fileName = $('#check_img').val();
        commonAjax.ajaxSubmit("app/upload/deleteImg.do","POST",fileName,function(result){
                if (result.success) {
                        // 图片清空
                        $('#a_bannerimg').attr("src", "").hide();
                        $('#btn_close').hide();
                        $('#uploadImg').attr("src", "../../images/addImg.png").show();
                        $('#check_img').val('');
                } else {
                        alert('系统错误！');
                }
        });

});


/**
 * 上传图片
 */
uploadImg : function (flag) {

        var button;
        var upload_url;
        var upload_name;
        upload_name = 'uploadImg';
        button = $('#uploadImg');
        upload_url = commonAjax.defaultOption.url + 'app/upload/uploadImg.do';
    new AjaxUpload(button,{
        action: upload_url,
        name: upload_name,   //这相当于<input type = "file" name = "shanghaiFile"/>
        onSubmit : function(file, ext){
            if (ext && /^(jpg|png)$/.test(ext)){
                // ...
            } else {
                alert('非图片类型文件，请重传！');
                return false;
            }
        },
        onComplete: function(file, response){ //上传完毕后的操作
                //有了response我们能做任何事了,返回的文件名称,文件路径等我们可以随意操作的!
                var data = JSON.parse(response);
                if (data.success) {
                        var url_img = data.resData;
                        var name_img = url_img.substring(url_img.lastIndexOf('/') + 1);
                        // 填充轮播图
                        $('#a_bannerimg').attr("src", url_img).show();
                        $('#btn_close').show();
                                $('#uploadImg').hide();
                                $('#check_img').val(name_img);
                                $('#check_img-error').remove();
                        } else {
                                alert('图片上传失败！');
                        }
        }
    });
},
**** Html代码
<div style="width:150px;">
        <button type="button" class="close" imgId="" id="btn_close" style="display: none" aria-label="Close">
                <span aria-hidden="true">&times;</span>
        </button>
             <a href="#"><img class="img-rounded" src="../../images/addImg.png" id="uploadImg" style="width: 135px;max-height: 105px"/></a>
                <img class="img-rounded" src="" id="a_bannerimg" style="width: 135px;max-height: 105px; display: none; "/>
        <input type="hidden" value="" id="check_img" name="check_img" />
</div>
**** java代码
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 本地文件存储路径  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/** 本地 文件保存路径 */
public static final String FILEPATH_URL = "d://IMGNFS/";
/** APPA-轮播图-本地保存路径 */
public static final String FILEPATH_APP_BANNER_IMG = FILEPATH_URL + "app_banner_img/";
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 文件服务器  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/** 文件服务器  D D 地址 */
public static final String URL_FILE = "http://121.40.97.206";
/** 文件服务器  D D APACHE端口 */
public static final String PORT_FILE = ":8099";
/** 文件服务器  D D 请求地址 */
public static final String FILESERVER_URL = URL_FILE + ":9010/fileServer-web/fileUpload";
/** 文件服务器  D D  api请求地址 */
public static final String UPLOAD_URL = FILESERVER_URL + "/upload",
                                                   DELETE_URL = FILESERVER_URL + "/delete";
/** 文件服务器  D D  APP轮播图-图片-保存路径 */
public static final String URL_APP_BANNER_IMG = "/app_banner_img/";

/**
 * 图片上传action
 * @author lz
 * @date 2016年3月17日
 */
@Controller
@RequestMapping("app/upload")
public class AppUploadAction {

        /** 日志 */
        private static Logger log = Logger.getLogger(AppUploadAction.class);

        /**
         * 上传图片
         * @param session
         * @param mFile
         * @return
         * @author lz
         * @date 2016年3月17日
         */
        @ResponseBody
        @RequestMapping("/uploadImg")
        public String addImg(HttpSession session,
                        @RequestParam("uploadImg") CommonsMultipartFile mFile){

                log.info(GlobalContract.LOG_BEGIN);
                ResultVO resultVO = null;

                try {
                        if (!mFile.isEmpty()) {
                                Map<String, String> map = UploadImgUtil.uploadImg(
                                                mFile,
                                                FileOptionUtil.getfileName(),
                                                GlobalContract.FILEPATH_APP_BANNER_IMG,
                                                GlobalContract.URL_FILE.concat(GlobalContract.PORT_FILE)
                                                                                           .concat(GlobalContract.URL_APP_BANNER_IMG));

                                // 上传图片到文件服务器
                                List<String> list = new ArrayList<String>(1);
                                list.add(GlobalContract.FILEPATH_APP_BANNER_IMG + map.get("imgName"));
                                HttpClientUtil.postFile(list, GlobalContract.URL_APP_BANNER_IMG);

                                resultVO = new ResultVO();
                                resultVO.setResData(map.get("imgUrl"));
                        } else {
                                resultVO = new ResultVO(GlobalMessage.MSG_01);
                        }
                } catch (Exception e) {
                        e.printStackTrace();
                        resultVO = new ResultVO(GlobalMessage.MSG_01);
                        log.error("错误信息：" + e.getMessage());
                }

                log.info(GlobalContract.LOG_END);
                return JSONObject.fromObject(resultVO).toString();
        }

        /**
         * 删除图片
         * @param session
         * @param imgName
         * @return
         * @author lz
         * @date 2016年3月17日
         */
        @ResponseBody
        @RequestMapping("/deleteImg")
        public String deleteImg(HttpSession session, @RequestBody String imgName){

                log.info(GlobalContract.LOG_BEGIN);
                ResultVO resultVO = null;

                try {
                        if (imgName!=null && !imgName.isEmpty()) {
                                if(!UploadImgUtil.deleteImg(imgName, GlobalContract.FILEPATH_APP_BANNER_IMG)){
                                        log.error("错误信息：删除轮播图失败" + imgName);
                                        System.err.println(imgName + "图片不存在！");
                                } else {
                                        // 远程删除缩略图
                                        HttpRequestUtil.sendPost(GlobalContract.DELETE_URL, "fileNameArr="+imgName);
                                }
                                resultVO = new ResultVO();
                        } else {
                                resultVO = new ResultVO(GlobalMessage.MSG_01);
                        }
                } catch (Exception e) {
                        e.printStackTrace();
                        resultVO = new ResultVO(GlobalMessage.MSG_01);
                        log.error("错误信息：" + e.getMessage());
                }

                log.info(GlobalContract.LOG_END);
                return JSONObject.fromObject(resultVO).toString();
        }
}

*** Base64上传图片
**** Base64Util.java
/**
 * Base64加密解密
 * @author lz
 * @date 2016年3月17日
 */
public class Base64Util {

        /**
         * 加密字符串
         * @Title encodeStr
         * @param str 明文
         * @return
         * @author 蔡志同
         * @date 2014年12月1日 下午1:42:07
         */
        public static byte[] decryptBASE64(String str){

                return (new Base64()).encode(str.getBytes());
        }

        /**
         * 解密字符串
         * @Title decodeStr
         * @param key 密文
         * @return
         * @author 蔡志同
         * @date 2014年12月1日 下午1:41:56
         */
        public static String encryptBASE64(byte[] key){

                return new String((new Base64()).decode(key));
        }

        /**
         * 对文件进行编码
         * @Title GetImageStr
         * @param file
         * @return
         * @throws Exception
         * @author 蔡志同
         * @date 2014年12月24日 下午1:48:00
         */
        public static String encodeFile(File file) throws Exception {

                InputStream in = new FileInputStream(file);
                byte[] data = new byte[in.available()];
                in.read(data);
                in.close();
                return new String((new Base64()).encode(data));
        }

        /**
     * 对文件进行解码
     * @param oldString 需要解码的字符串
     * @param filePath  将字符串解码到filepath文件路径
     * @return  返回解码后得到的文件
     * @throws Exception
     */
    public static void decodeFile(String fileString, String filePath) throws Exception{

        File file = new File(filePath);

        if(file.exists()){
                file.delete();
        }

        file.createNewFile();

        FileOutputStream out = new FileOutputStream(file);
        byte[] debytes = null;
        if (fileString != null) {
                        debytes = new Base64().decode(fileString.getBytes());
                }
        out.write(debytes);
        out.close();
    }
    /**
     * 生成文件名称
     * @return
     * @author czt
     * @time 2015年10月21日 上午10:39:34
     */
        public static String getfileName() {

                long date = System.currentTimeMillis() / 10;
                if (GlobalContract.COUNT == 999) {
                        GlobalContract.COUNT = 100;
                } else {
                        GlobalContract.COUNT++;
                }
                return date + "" + GlobalContract.COUNT;
        }


}

**** java代码
// 处理图片
String img_base64 = clubVO.getClubImg();
if (!img_base64.isEmpty()) {
        // 图片保存路径
        String filePath = GlobalContract.FILEPATH_URL;
        File dir = new File(filePath);
        if (!dir.exists()) {
                dir.mkdirs();
        }
        String fileFormat = ".".concat(img_base64.substring(11, img_base64.indexOf(";")));
        String fileData = img_base64.substring(img_base64.indexOf(",")+1);
        String fileName = Base64Util.getfileName().concat(fileFormat);
        Base64Util.decodeFile(fileData, filePath.concat(fileName));

        List<String> list = new ArrayList<String>(1);
        list.add( GlobalContract.FILEPATH_URL.concat(fileName));
        HttpClientUtil.postFile(list, GlobalContract.URL_CLUB_IMG);
        dto.setClubImg(fileName);
}
**** js代码
// 选择照片
$('#img_chooseImg').click(function(){
        $('#btn_chooseImg').click();
});

// 删除图片
$('#btn_close').click(function(){

        // 图片清空
        $('#a_clubImg').attr("src", "").hide();
        $('#btn_close').hide();
        $('#img_chooseImg').attr("src", "../../images/addImg.png").show();
        $('#btn_chooseImg').val('');
        $('#check_img').val('');
});

/**
 * base64处理图片
 */
init_base64 : function () {
        club_add.defaultOption.init_flag = 1;
        if (typeof (FileReader) === undefined) {
                layer.msg("抱歉，你的浏览器版本过低！");
                $('#btn_chooseImg').attr("disable", "disable");
        } else {
                $('#btn_chooseImg').change(function(){
                        var file = this.files[0];
                        if (file) {
                                //这里我们判断下类型如果不是图片就返回 去掉就可以上传任意文件
                                if (!/image\/\w+/.test(file.type)) {
                                        layer.msg("请确保文件为图像类型");
                                        return false;
                                }
                                var reader = new FileReader();
                                reader.readAsDataURL(file);
                                reader.onload = function(e) {
                                        $('#a_clubImg').attr("src", this.result).show();
                                        $('#btn_close').show();
                                        $('#img_chooseImg').hide();
                                        $('#check_img').val(1);
                                        $('#check_img-error').remove();
                                }
                        }
                });
        }
},
**** Html代码
<div style="width:150px;">
<input type="file" accept="image/*" id="btn_chooseImg" style="display: none;" />
        <button type="button" class="close" imgId="" id="btn_close" style="display: none" aria-label="Close">
                <span aria-hidden="true">&times;</span>
        </button>
               <a href="#"><img class="img-rounded" src="../../images/addImg.png" id="img_chooseImg" style="width: 135px;"/></a>
               <img class="img-rounded" src="" id=a_clubImg style="width: 135px; display: none; "/>
<input type="hidden" value="" id="check_img" name="check_img" /></div>
** problem
* Js
** problem
*** ie9虚文字处理
jquery.enplaceholder.js
$('.wrap-placeholder').show();
$('.wrap-placeholder').hide();
$('#formatName').placeholder({isUseSpan:true,onInput:false}); 
** jquery note
*** 选择器
$(".intro.demo")	所有 class="intro" 且 class="demo" 的元素
$(this)	当前 HTML 元素
$("p.intro")	所有 class="intro" 的 <p> 元素
$("div#intro .head")	id="intro" 的 <div> 元素中的所有 class="head" 的元素

:first	$("p:first")	第一个 <p> 元素
:last	$("p:last")	最后一个 <p> 元素
:even	$("tr:even")	所有偶数 <tr> 元素
:odd	    $("tr:odd")	所有奇数 <tr> 元素

:eq(index)	$("ul li:eq(3)")	列表中的第四个元素（index 从 0 开始）
:gt(no)	$("ul li:gt(3)")	列出 index 大于 3 的元素
:lt(no)	$("ul li:lt(3)")	列出 index 小于 3 的元素
:not(selector)	$("input:not(:empty)")	所有不为空的 input 元素

:header	      $(":header")	所有标题元素 <h1> - <h6>
:animated	 	               所有动画元素

s1,s2,s3	$("th,td,.intro")	所有带有匹配选择的元素

:contains(text)	$(":contains('W3School')")	包含指定字符串的所有元素
:empty	$(":empty")	无子（元素）节点的所有元素
:hidden	$("p:hidden")	所有隐藏的 <p> 元素
:visible	$("table:visible")	所有可见的表格

[attribute]	       $("[href]")	所有带有 href 属性的元素
[attribute=value]	$("[href='#']")	所有 href 属性的值等于 "#" 的元素
[attribute!=value]	$("[href!='#']")	所有 href 属性的值不等于 "#" 的元素
[attribute$=value]	$("[href$='.jpg']")	所有 href 属性的值包含以 ".jpg" 结尾的元素

:input	$(":input")	所有 <input> 元素
:text	$(":text")	所有 type="text" 的 <input> 元素
:password	$(":password")	所有 type="password" 的 <input> 元素
:radio	$(":radio")	所有 type="radio" 的 <input> 元素
:checkbox	$(":checkbox")	所有 type="checkbox" 的 <input> 元素
:submit	$(":submit")	所有 type="submit" 的 <input> 元素
:reset	$(":reset")	所有 type="reset" 的 <input> 元素
:button	$(":button")	所有 type="button" 的 <input> 元素
:image	$(":image")	所有 type="image" 的 <input> 元素
:file	$(":file")	所有 type="file" 的 <input> 元素

:enabled	$(":enabled")	所有激活的 input 元素
:disabled	$(":disabled")	所有禁用的 input 元素
:selected	$(":selected")	所有被选取的 input 元素
:checked	$(":checked")	所有被选中的 input 元素

*** 事件
bind()	向匹配元素附加一个或更多事件处理器
blur()	触发、或将函数绑定到指定元素的 blur 事件
dblclick()	触发、或将函数绑定到指定元素的 double click 事件
delegate()	向匹配元素的当前或未来的子元素附加一个或多个事件处理器
die()	移除所有通过 live() 函数添加的事件处理程序。
error()	触发、或将函数绑定到指定元素的 error 事件
event.isDefaultPrevented()	返回 event 对象上是否调用了 event.preventDefault()。
event.pageX	相对于文档左边缘的鼠标位置。
event.pageY	相对于文档上边缘的鼠标位置。
event.preventDefault()	阻止事件的默认动作。
event.result	包含由被指定事件触发的事件处理器返回的最后一个值。
event.target	触发该事件的 DOM 元素。
event.timeStamp	该属性返回从 1970 年 1 月 1 日到事件发生时的毫秒数。
event.type	描述事件的类型。
event.which	指示按了哪个键或按钮。
focus()	触发、或将函数绑定到指定元素的 focus 事件
keydown()	触发、或将函数绑定到指定元素的 key down 事件
keypress()	触发、或将函数绑定到指定元素的 key press 事件
keyup()	触发、或将函数绑定到指定元素的 key up 事件
live()	为当前或未来的匹配元素添加一个或多个事件处理器
load()	触发、或将函数绑定到指定元素的 load 事件
mousedown()	触发、或将函数绑定到指定元素的 mouse down 事件
mouseenter()	触发、或将函数绑定到指定元素的 mouse enter 事件
mouseleave()	触发、或将函数绑定到指定元素的 mouse leave 事件
mousemove()	触发、或将函数绑定到指定元素的 mouse move 事件
mouseout()	触发、或将函数绑定到指定元素的 mouse out 事件
mouseover()	触发、或将函数绑定到指定元素的 mouse over 事件
mouseup()	触发、或将函数绑定到指定元素的 mouse up 事件
one()	向匹配元素添加事件处理器。每个元素只能触发一次该处理器。
ready()	文档就绪事件（当 HTML 文档就绪可用时）
resize()	触发、或将函数绑定到指定元素的 resize 事件
scroll()	触发、或将函数绑定到指定元素的 scroll 事件
select()	触发、或将函数绑定到指定元素的 select 事件
submit()	触发、或将函数绑定到指定元素的 submit 事件
toggle()	绑定两个或多个事件处理器函数，当发生轮流的 click 事件时执行。
trigger()	所有匹配元素的指定事件
triggerHandler()	第一个被匹配元素的指定事件
unbind()	从匹配元素移除一个被添加的事件处理器
undelegate()	从匹配元素移除一个被添加的事件处理器，现在或将来
unload()	触发、或将函数绑定到指定元素的 unload 事件
*** 文档操作
addClass()	向匹配的元素添加指定的类名。
after()	在匹配的元素之后插入内容。
append()	向匹配元素集合中的每个元素结尾插入由参数指定的内容。
appendTo()	向目标结尾插入匹配元素集合中的每个元素。
attr()	设置或返回匹配元素的属性和值。
before()	在每个匹配的元素之前插入内容。
clone()	创建匹配元素集合的副本。
detach()	从 DOM 中移除匹配元素集合。
empty()	删除匹配的元素集合中所有的子节点。
hasClass()	检查匹配的元素是否拥有指定的类。
html()	设置或返回匹配的元素集合中的 HTML 内容。
insertAfter()	把匹配的元素插入到另一个指定的元素集合的后面。
insertBefore()	把匹配的元素插入到另一个指定的元素集合的前面。
prepend()	向匹配元素集合中的每个元素开头插入由参数指定的内容。
prependTo()	向目标开头插入匹配元素集合中的每个元素。
remove()	移除所有匹配的元素。
removeAttr()	从所有匹配的元素中移除指定的属性。
removeClass()	从所有匹配的元素中删除全部或者指定的类。
replaceAll()	用匹配的元素替换所有匹配到的元素。
replaceWith()	用新内容替换匹配的元素。
text()	设置或返回匹配元素的内容。
toggleClass()	从匹配的元素中添加或删除一个类。
unwrap()	移除并替换指定元素的父元素。
val()	设置或返回匹配元素的值。
wrap()	把匹配的元素用指定的内容或元素包裹起来。
wrapAll()	把所有匹配的元素用指定的内容或元素包裹起来。
wrapinner()	将每一个匹配的元素的子内容用指定的内容或元素包裹起来。
*** css类
addClass() - 向被选元素添加一个或多个类
removeClass() - 从被选元素删除一个或多个类
toggleClass() - 对被选元素进行添加/删除类的切换操作
css() - 设置或返回样式属性

offset()	返回第一个匹配元素相对于文档的位置。
offsetParent()	返回最近的定位祖先元素。
position()	返回第一个匹配元素相对于父元素的位置。

$("h1,h2,p").toggleClass("blue");

$("p").css("background-color");
$("p").css("background-color","yellow");
*** 遍历
**** 祖先
parent() 方法返回被选元素的直接父元素。
parents() 方法返回被选元素的所有祖先元素，它一路向上直到文档的根元素 (<html>)。
$("span").parents("ul");
parentsUntil() 方法返回介于两个给定元素之间的所有祖先元素。
$("span").parentsUntil("div");

**** 后代
children() 方法返回被选元素的所有直接子元素。该方法只会向下一级对 DOM 树进行遍历。
下面的例子返回类名为 "1" 的所有 <p> 元素，并且它们是 <div> 的直接子元素：
$("div").children("p.1");

find() 方法返回被选元素的后代元素，一路向下直到最后一个后代。
 $("div").find("span");
**** 同胞
siblings() 方法返回被选元素的所有同胞元素。
$("h2").siblings(); $("h2").siblings("p");

next() 方法返回被选元素的下一个同胞元素。 该方法只返回一个元素。不可以带参数

nextAll() 方法返回被选元素的所有跟随的同胞元素。
$("h2").nextAll();  $("h2").nextAll('span');

nextUntil() 方法返回介于两个给定参数之间的所有跟随的同胞元素。
prev(), prevAll() 以及 prevUntil() 方法的工作方式与上面的方法类似，只不过方向相反而已
**** 过滤
first() 方法返回被选元素的首个元素。
$("div p").first();选取首个 <div> 元素内部的第一个 <p> 元素：

last() 方法返回被选元素的最后一个元素。

eq() 方法返回被选元素中带有指定索引号的元素。

filter() 方法允许您规定一个标准。不匹配这个标准的元素会被从集合中删除，匹配的元素会被返回。
$("p").filter(".intro"); 返回带有类名 "intro" 的所有 <p> 元素：
filter() 方法允许您规定一个标准。不匹配这个标准的元素会被从集合中删除，匹配的元素会被返回。
$("p").filter(".intro"); 返回带有类名 "intro" 的所有 <p> 元素：
**** 总结
.add()	将元素添加到匹配元素的集合中。
.andSelf()	把堆栈中之前的元素集添加到当前集合中。
.children()	获得匹配元素集合中每个元素的所有子元素。
.closest()	从元素本身开始，逐级向上级元素匹配，并返回最先匹配的祖先元素。
.contents()	获得匹配元素集合中每个元素的子元素，包括文本和注释节点。
.each()	对 jQuery 对象进行迭代，为每个匹配元素执行函数。
.end()	结束当前链中最近的一次筛选操作，并将匹配元素集合返回到前一次的状态。
.eq()	将匹配元素集合缩减为位于指定索引的新元素。
.filter()	将匹配元素集合缩减为匹配选择器或匹配函数返回值的新元素。
.find()	获得当前匹配元素集合中每个元素的后代，由选择器进行筛选。
.first()	将匹配元素集合缩减为集合中的第一个元素。
.has()	将匹配元素集合缩减为包含特定元素的后代的集合。
.is()	根据选择器检查当前匹配元素集合，如果存在至少一个匹配元素，则返回 true。
.last()	将匹配元素集合缩减为集合中的最后一个元素。
.map()	把当前匹配集合中的每个元素传递给函数，产生包含返回值的新 jQuery 对象。
.next()	获得匹配元素集合中每个元素紧邻的同辈元素。
.nextAll()	获得匹配元素集合中每个元素之后的所有同辈元素，由选择器进行筛选（可选）。
.nextUntil()	获得每个元素之后所有的同辈元素，直到遇到匹配选择器的元素为止。
.not()	从匹配元素集合中删除元素。
.offsetParent()	获得用于定位的第一个父元素。
.parent()	获得当前匹配元素集合中每个元素的父元素，由选择器筛选（可选）。
.parents()	获得当前匹配元素集合中每个元素的祖先元素，由选择器筛选（可选）。
.parentsUntil()	获得当前匹配元素集合中每个元素的祖先元素，直到遇到匹配选择器的元素为止。
.prev()	获得匹配元素集合中每个元素紧邻的前一个同辈元素，由选择器筛选（可选）。
.prevAll()	获得匹配元素集合中每个元素之前的所有同辈元素，由选择器进行筛选（可选）。
.prevUntil()	获得每个元素之前所有的同辈元素，直到遇到匹配选择器的元素为止。
.siblings()	获得匹配元素集合中所有元素的同辈元素，由选择器筛选（可选）。
.slice()	将匹配元素集合缩减为指定范围的子集。
*** ajax
**** 加载
load() 方法从服务器加载数据，并把返回的数据放入被选元素中
$(selector).load(URL,data,callback);
也可以把 jQuery 选择器添加到 URL 参数
$("#div1").load("demo_test.txt #p1"); 把 "demo_test.txt" 文件中 id="p1" 的元素的内容，加载到指定的 <div> 元素中：

jQuery.ajax()	执行异步 HTTP (Ajax) 请求。
.ajaxComplete()	当 Ajax 请求完成时注册要调用的处理程序。这是一个 Ajax 事件。
.ajaxError()	当 Ajax 请求完成且出现错误时注册要调用的处理程序。这是一个 Ajax 事件。
.ajaxSend()	在 Ajax 请求发送之前显示一条消息。
jQuery.ajaxSetup()	设置将来的 Ajax 请求的默认值。
.ajaxStart()	当首个 Ajax 请求完成开始时注册要调用的处理程序。这是一个 Ajax 事件。
.ajaxStop()	当所有 Ajax 请求完成时注册要调用的处理程序。这是一个 Ajax 事件。
.ajaxSuccess()	当 Ajax 请求成功完成时显示一条消息。
jQuery.get()	使用 HTTP GET 请求从服务器加载数据。
jQuery.getJSON()	使用 HTTP GET 请求从服务器加载 JSON 编码数据。
jQuery.getScript()	使用 HTTP GET 请求从服务器加载 JavaScript 文件，然后执行该文件。
.load()	从服务器加载数据，然后把返回到 HTML 放入匹配元素。
jQuery.param()	创建数组或对象的序列化表示，适合在 URL 查询字符串或 Ajax 请求中使用。
jQuery.post()	使用 HTTP POST 请求从服务器加载数据。
.serialize()	将表单内容序列化为字符串。
.serializeArray()	序列化表单元素，返回 JSON 数据结构数据。
**** get/post
GET 基本上用于从服务器获得（取回）数据。
GET 请求可被缓存
GET 请求保留在浏览器历史记录中
GET 请求可被收藏为书签
GET 请求不应在处理敏感数据时使用
GET 请求有长度限制
GET 请求只应当用于取回数据


POST 也可用于从服务器获取数据。
POST 请求不会被缓存
POST 请求不会保留在浏览器历史记录中
POST 不能被收藏为书签
POST 请求对数据长度没有要求

其他 HTTP 请求方法
下面的表格列出了其他一些 HTTP 请求方法：
方法	描述
HEAD	与 GET 相同，但只返回 HTTP 报头，不返回文档主体。
PUT	上传指定的 URI 表示。
DELETE	删除指定资源。
OPTIONS	返回服务器支持的 HTTP 方法。
CONNECT	把请求连接转换到透明的 TCP/IP 通道。
*** 效果
animate()	对被选元素应用“自定义”的动画
clearQueue()	对被选元素移除所有排队的函数（仍未运行的）
delay()	对被选元素的所有排队函数（仍未运行）设置延迟
dequeue()	运行被选元素的下一个排队函数
fadeIn()	逐渐改变被选元素的不透明度，从隐藏到可见
fadeOut()	逐渐改变被选元素的不透明度，从可见到隐藏
fadeTo()	把被选元素逐渐改变至给定的不透明度
hide()	隐藏被选的元素
queue()	显示被选元素的排队函数
show()	显示被选的元素
slideDown()	通过调整高度来滑动显示被选元素
slideToggle()	对被选元素进行滑动隐藏和滑动显示的切换
slideUp()	通过调整高度来滑动隐藏被选元素
stop()	停止在被选元素上运行动画
toggle()	对被选元素进行隐藏和显示的切换
* sql
** mysql获取指定数据库所有表名和获取指定表所有字段名
查询数据库中所有表名
select table_name from information_schema.tables where table_schema='csdb' and table_type='base table';

查询指定数据库中指定表的所有字段名column_name
select column_name,column_comment,data_type from information_schema.columns where table_name = 't_weather'

MySql获取表的字段名称、字段注解、字段类型、字段长度
SELECT  COLUMN_NAME as '列名',COLUMN_COMMENT as '字段注释',DATA_TYPE as '字段类型' ,COLUMN_TYPE as '长度加类型' FROM information_schema.`COLUMNS` where TABLE_NAME ='t_weather'

mysql获取表名，表注释，字段名称，字段注解，字段类型
SELECT
        t.TABLE_NAME,
        t.TABLE_COMMENT,
        c.COLUMN_NAME,
        c.COLUMN_COMMENT,
        c.DATA_TYPE
FROM
        information_schema.`TABLES` t
LEFT JOIN information_schema.`COLUMNS` c on c.TABLE_NAME = t.TABLE_NAME
WHERE
        t.TABLE_NAME = 't_weather'
** oracle获取指定数据库所有表名和获取指定表所有字段名
查询指定表的字段名、注释、数据类型,字段长度,是否可以为空
select t.COLUMN_NAME,(select c.comments from user_col_comments c where c.table_name = t.TABLE_NAME and c.column_name = t.COLUMN_NAME) as comments,t.DATA_TYPE,t.DATA_LENGTH,t.NULLABLE from user_tab_columns t where t.table_name = '$tab_name'
查询指定表的字段名、注释、
select column_name,comments from user_col_comments where table_name = 'T_F1_CLUB';
获取表名，表注释：
select t.COMMENTS,t.table_name from user_tab_comments t where Table_Name='T_F1_CLUB'
** MongoDB安装
以管理员方式运行，
1. mongod.exe --dbpath=c:\data\db  --logpath=c:\data\db\log\log.txt
2. mongod.exe --install --dbpath=c:\data\db  --logpath=c:\data\db\log\log.txt
3. net start mongodb 启动mongodb服务
   net stop mongodb 启动mongodb服
** ibatis
*** 批量新增和修改
ibatis
this.getSqlMapClientTemplate().execute(new SqlMapClientCallback<Object>() {
			@Override
			public Object doInSqlMapClient(SqlMapExecutor executor) throws SQLException {
				executor.startBatch();
				for (int i = 0; i < list.size(); i++) {
					executor.insert("clubRolemenu.insertRoleMenu", list.get(i));
				}
				executor.executeBatch();
				return null;
			}
		});


mybatis
<insert  id="updateRepairPerson"  parameterType="java.util.List">
        insert into t_repair_person (ORDER_ID,PERSON_ID,UPDATE_USERID)
        values
        <foreach collection="list" item="item" index="index" open="" close="" separator=",">
            (#{item.order_id},#{item.person_id},#{item.update_userid})
        </foreach>
    </insert>  

<update id="updatePartsList"  parameterType="java.util.List">  
        <foreach collection="list" item="item" index="index" open="" close="" separator=";">
            update t_parts_list
            <set>
                PARTS_PRICE=${item.parts_price}
            </set>
            where PARTS_ID = ${item.parts_id}
        </foreach>      
    </update>

var vo = new Object();
var partsArr = new Array();
var partsVO = null; 
$('.parts_list').each(function(i){
    partsVO = new Object();//т??г
    partsVO.parts_id = $(this).find('#parts_id').val();
    partsVO.parts_price = $(this).find('#parts_price').val();
    partsArr.push(partsVO);
});
vo.partslist = partsArr;  
** 根据经纬度算距离函数
 CREATE  FUNCTION `getDistance`(curLat DOUBLE, curLon DOUBLE, shopLat DOUBLE, shopLon DOUBLE) RETURNS double
BEGIN  
  DECLARE  dis DOUBLE;  
    set dis = ACOS(SIN((curLat * 3.1415) / 180 ) * SIN((shopLat * 3.1415) / 180 ) + COS((curLat * 3.1415) / 180 ) * COS((shopLat * 3.1415) / 180 ) * COS((curLon * 3.1415) / 180 - (shopLon * 3.1415) / 180 ) ) * 6380 ;  
    RETURN dis;  
END 
** 获取多表总数
SELECT
	sum(c.M)
FROM
	(
		SELECT
			count(r.ORDER_ID) M
		FROM
			t_repair_order r
		WHERE
			r.DELFLAG = '0'
		AND r.ORDER_STATUS = '1'
		UNION
			SELECT
				count(p.PARTS_ORDER_ID) M
			FROM
				t_parts_order p
			WHERE
				p.DELFLAG = '0'
			AND p.PARTS_ORDER_STATUS = '1'
			
	) C

select t1.num1,t2.num2 from 
  (select count(*) num1 from table1) t1,
  (select count(*) num2 from table2) t2

select t1.num1,+t2.num2 from 
  (select count(*) num1 from table1) t1,
  (select count(*) num2 from table2) t2
** 拼接查询
group_concat(b.PARTS_BUY_PRICE),
group_concat(b.PARTS_BUY_COUNT)
ORDER BY t.PARTS_ORDER_ID
** 连接查询
INNER JOIN 关键字在表中存在至少一个匹配时返回行
LEFT JOIN 关键字会从左表 (Persons) 那里返回所有的行，
RIGHT JOIN 关键字会从右表 (Orders) 那里返回所有的行
FULL JOIN 关键字会从左表 (Persons) 和右表 (Orders) 那里返回所有的行。
** 返回规定的记录数目
SQL Server：
SELECT TOP number|percent column_name(s)
FROM table_name

SELECT TOP 50 PERCENT * FROM Persons（从"Persons" 表中选取 50% 的记录）

MySQL：
SELECT column_name(s)
FROM table_name
LIMIT number

Oracle：
SELECT column_name(s)
FROM table_name
WHERE ROWNUM <= number
** 通配符
%	替代一个或多个字符
_	仅替代一个字符
[charlist]	字符列中的任何单一字符
[^charlist]或者 [!charlist]  不在字符列中的任何单一字符

从"Persons" 表中选取居住的城市以 "A" 或 "L" 或 "N" 开头的人：
SELECT * FROM Persons
WHERE City LIKE '[ALN]%'
** IN BETWEEN
SELECT * FROM Persons
WHERE LastName IN ('Adams','Carter')

BETWEEN包含边界
** DISTINCT（返回唯一不同的值）
SELECT DISTINCT Company FROM Orders 
** UNION （合并两个或多个 SELECT 语句的结果集）
UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。
默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。
另外，UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。

SELECT E_Name FROM Employees_China
UNION
SELECT E_Name FROM Employees_USA
** EXCEPT 
运算符通过包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个结果表。
当 ALL 随 EXCEPT 一起使用时 (EXCEPT ALL)，不消除重复行。 
** INTERSECT
INTERSECT 运算符通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表。
当 ALL 随 INTERSECT 一起使用时 (INTERSECT ALL)，不消除重复行。 
** SQL SELECT INTO 语句
SELECT INTO 语句从一个表中选取数据，然后把数据插入另一个表中。
SELECT INTO 语句常用于创建表的备份复件或者用于对记录进行存档。

下面的例子会制作 "Persons" 表的备份复件：
SELECT *
INTO Persons_backup
FROM Persons
IN 子句可用于向另一个数据库中拷贝表：
SELECT *
INTO Persons IN 'Backup.mdb'
FROM Persons
如果我们希望拷贝某些域，可以在 SELECT 语句后列出这些域：
SELECT LastName,FirstName
INTO Persons_backup
FROM Persons
** CREATE
CREATE DATABASE 用于创建数据库。

CREATE DATABASE database_name

CREATE TABLE 语句用于创建数据库中的表。
CREATE TABLE Persons
(
Id_P int,
LastName varchar(255),
FirstName varchar(255),
Address varchar(255),
City varchar(255)
)
** select update insert delete
SELECT LastName,FirstName FROM Persons
INSERT INTO Persons VALUES ('Gates', 'Bill', 'Xuanwumen 10', 'Beijing')
UPDATE Person SET FirstName = 'Fred' WHERE LastName = 'Wilson' 
DELETE FROM Person WHERE LastName = 'Wilson' 
删除所有行 DELETE FROM table_name 或者：DELETE * FROM table_name
** SQL 约束 (Constraints)
约束用于限制加入表的数据的类型。
可以在创建表时规定约束（通过 CREATE TABLE 语句），或者在表创建之后也可以（通过 ALTER TABLE 语句）。
**** NOT NULL  约束强制列不接受 NULL 值。 
CREATE TABLE Persons
(
Id_P int NOT NULL,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255)
)
**** UNIQUE  约束唯一标识数据库表中的每条记录
UNIQUE 和 PRIMARY KEY 约束均为列或列集合提供了唯一性的保证。
PRIMARY KEY 拥有自动定义的 UNIQUE 约束。
每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束

*SQL UNIQUE Constraint on CREATE TABLE*
下面的 SQL 在 "Persons" 表创建时在 "Id_P" 列创建 UNIQUE 约束：
MySQL:
CREATE TABLE Persons
(
Id_P int NOT NULL,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255),
UNIQUE (Id_P)
)
SQL Server / Oracle / MS Access:
CREATE TABLE Persons
(
Id_P int NOT NULL UNIQUE,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255)
)
*如果需要命名 UNIQUE 约束，以及为多个列定义 UNIQUE 约束，请使用下面的 SQL 语法：*
MySQL / SQL Server / Oracle / MS Access:
CREATE TABLE Persons
(
Id_P int NOT NULL,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255),
CONSTRAINT uc_PersonID UNIQUE (Id_P,LastName)
)

SQL UNIQUE Constraint on ALTER TABLE
*当表已被创建时，如需在 "Id_P" 列创建 UNIQUE 约束，请使用下列 SQL：*
MySQL / SQL Server / Oracle / MS Access:
ALTER TABLE Persons
ADD UNIQUE (Id_P)
如需命名 UNIQUE 约束，并定义多个列的 UNIQUE 约束，请使用下面的 SQL 语法：
MySQL / SQL Server / Oracle / MS Access:
ALTER TABLE Persons
ADD CONSTRAINT uc_PersonID UNIQUE (Id_P,LastName)

*撤销 UNIQUE 约束*
如需撤销 UNIQUE 约束，请使用下面的 SQL：
MySQL:
ALTER TABLE Persons
DROP INDEX uc_PersonID
SQL Server / Oracle / MS Access:
ALTER TABLE Persons
DROP CONSTRAINT uc_PersonID
**** PRIMARY KEY
PRIMARY KEY 约束唯一标识数据库表中的每条记录。
主键必须包含唯一的值。
主键列不能包含 NULL 值。
每个表都应该有一个主键，并且每个表只能有一个主键。

SQL PRIMARY KEY Constraint on CREATE TABLE
*下面的 SQL 在 "Persons" 表创建时在 "Id_P" 列创建 PRIMARY KEY 约束：*
MySQL:
CREATE TABLE Persons
(
Id_P int NOT NULL,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255),
PRIMARY KEY (Id_P)
)
SQL Server / Oracle / MS Access:
CREATE TABLE Persons
(
Id_P int NOT NULL PRIMARY KEY,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255)
)
*如果需要命名 PRIMARY KEY 约束，以及为多个列定义 PRIMARY KEY 约束，请使用下面的 SQL 语法：*
MySQL / SQL Server / Oracle / MS Access:
CREATE TABLE Persons
(
Id_P int NOT NULL,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255),
CONSTRAINT pk_PersonID PRIMARY KEY (Id_P,LastName)
)
SQL PRIMARY KEY Constraint on ALTER TABLE
*如果在表已存在的情况下为 "Id_P" 列创建 PRIMARY KEY 约束，请使用下面的 SQL：*
MySQL / SQL Server / Oracle / MS Access:
ALTER TABLE Persons
ADD PRIMARY KEY (Id_P)
*如果需要命名 PRIMARY KEY 约束，以及为多个列定义 PRIMARY KEY 约束，请使用下面的 SQL 语法：*
MySQL / SQL Server / Oracle / MS Access:
ALTER TABLE Persons
ADD CONSTRAINT pk_PersonID PRIMARY KEY (Id_P,LastName)
注释：如果您使用 ALTER TABLE 语句添加主键，必须把主键列声明为不包含 NULL 值（在表首次创建时）。
*撤销 PRIMARY KEY 约束*
如需撤销 PRIMARY KEY 约束，请使用下面的 SQL：
MySQL:
ALTER TABLE Persons
DROP PRIMARY KEY
SQL Server / Oracle / MS Access:
ALTER TABLE Persons
DROP CONSTRAINT pk_PersonID
**** FOREIGN KEY
MySQL:
CREATE TABLE Orders
(
Id_O int NOT NULL,
OrderNo int NOT NULL,
Id_P int,
PRIMARY KEY (Id_O),
FOREIGN KEY (Id_P) REFERENCES Persons(Id_P)
)
SQL Server / Oracle / MS Access:
CREATE TABLE Orders
(
Id_O int NOT NULL PRIMARY KEY,
OrderNo int NOT NULL,
Id_P int FOREIGN KEY REFERENCES Persons(Id_P)
)
**** CHECK  用于限制列中的值的范围
如果对单个列定义 CHECK 约束，那么该列只允许特定的值。
如果对一个表定义 CHECK 约束，那么此约束会在特定的列中对值进行限制。
My SQL:
CREATE TABLE Persons
(
Id_P int NOT NULL,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255),
CHECK (Id_P>0)
)
SQL Server / Oracle / MS Access:
CREATE TABLE Persons
(
Id_P int NOT NULL CHECK (Id_P>0),
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255)
)
**** DEFAULT  用于向列中插入默认值。

** INDEX(索引)
在不读取整个表的情况下，索引使数据库应用程序可以更快地查找数据
注释：更新一个包含索引的表需要比更新一个没有索引的表更多的时间，这是由于索引本身也需要更新。
因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引。

在表上创建一个简单的索引。允许使用重复的值：
CREATE INDEX index_name
ON table_name (column_name)
"column_name" 规定需要索引的列。

CREATE INDEX PersonIndex
ON Person (LastName, FirstName)

在表上创建一个唯一的索引。唯一的索引意味着两个行不能拥有相同的索引值。
CREATE UNIQUE INDEX index_name
ON table_name (column_name)
** DROP(SQL 撤销索引、表以及数据库)
oracle  DROP INDEX index_name
MySQL  ALTER TABLE table_name DROP INDEX index_name

** ALERT(用于在已有的表中添加、修改或删除列。)
ALTER TABLE table_name
ADD column_name datatype

ALTER TABLE table_name 
DROP COLUMN column_name

ALTER TABLE table_name
ALTER COLUMN column_name datatype
** Auto-increment (会在新记录插入表中时生成一个唯一的数字。)
我们通常希望在每次插入新记录时，自动地创建主键字段的值。

MySQL 的语法
下列 SQL 语句把 "Persons" 表中的 "P_Id" 列定义为 auto-increment 主键：
CREATE TABLE Persons
(
P_Id int NOT NULL AUTO_INCREMENT,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255),
PRIMARY KEY (P_Id)
)
要让 AUTO_INCREMENT 序列以其他的值起始，请使用下列 SQL 语法：
ALTER TABLE Persons AUTO_INCREMENT=100

Oracle 的语法
在 Oracle 中，代码稍微复杂一点。
您必须通过 sequence 对创建 auto-increment 字段（该对象生成数字序列）。
请使用下面的 CREATE SEQUENCE 语法：
CREATE SEQUENCE seq_person
MINVALUE 1
START WITH 1
INCREMENT BY 1
CACHE 10

上面的代码创建名为 seq_person 的序列对象，它以 1 起始且以 1 递增。该对象缓存 10 个值以提高性能。
CACHE 选项规定了为了提高访问速度要存储多少个序列值。
要在 "Persons" 表中插入新记录，我们必须使用 nextval 函数（该函数从 seq_person 序列中取回下一个值）：
INSERT INTO Persons (P_Id,FirstName,LastName)
VALUES (seq_person.nextval,'Lars','Monsen')
** VIEW
视图包含行和列，就像一个真实的表。

CREATE VIEW view_name AS
SELECT column_name(s)
FROM table_name
WHERE condition
** GROUP BY、 HAVING 
GROUP BY 语句用于结合合计函数，根据一个或多个列对结果集进行分组。

SELECT Customer,SUM(OrderPrice) FROM Orders
WHERE Customer='Bush' OR Customer='Adams'
GROUP BY Customer
HAVING SUM(OrderPrice)>1500
** 函数
AVG(column)	返回某列的平均值
COUNT(column)	返回某列的行数（不包括 NULL 值）
COUNT(*)	返回被选行数
FIRST(column)	返回在指定的域中第一个记录的值
LAST(column)	返回在指定的域中最后一个记录的值
MAX(column)	返回某列的最高值
MIN(column)	返回某列的最低值
SUM(column)	返回某列的总和
UCASE 函数把字段的值转换为大写。
LCASE 函数把字段的值转换为小写。
**** MID 函数用于从文本字段中提取字符。
SELECT MID(column_name,start[,length]) FROM table_name
参数	描述
column_name	必需。要提取字符的字段。
start	必需。规定开始位置（起始值是 1）。
length	可选。要返回的字符数。如果省略，则 MID() 函数返回剩余文本。
** 常识
在SQL查询中：from后最多可以跟多少张表或视图：256
在SQL语句中出现 Order by,查询时，先排序，后取
在SQL中，一个字段的最大容量是8000，而对于nvarchar(4000),由于nvarchar是Unicode码。 
** 索引
http://blog.jobbole.com/86594/

*建索引的几大原则*
1.最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。

2.=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式

3.尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录

4.索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);

5.尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可

*慢查询优化基本步骤*

0.先运行看看是否真的很慢，注意设置SQL_NO_CACHE
1.where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高
2.explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）
3.order by limit 形式的sql语句让排序的表优先查
4.了解业务方使用场景
5.加索引时参照建索引的几大原则
6.观察结果，不符合预期继续从0分析
* org-mode
** 快捷键
*** 列表
M-RET 插入同级列表项
M-S-RET 插入有 checkbox的同级列表项
C-c C-c 改变 checkbox状态
M-left/right 改变列表项层级关系
M-up/dowm 上下移动列表项
C-c C-n 移动到下一个标题
C-c C-p 移动到上一个标题
C-c C-f 移动到和当前标题同等级的下一个标题
C-c C-b 移动到和当前标题同等级的上一个标题
C-c C-u 向上移动到更高一层的标题
*** 待办事项（TODO ）
C-c C-t或者 S-LEFT/RIGTH  变换TODO的状态
C-c / t以树的形式展示所有的 TODO
C-c C-c 改变 checkbox状态
C-c, 设置优先级（方括号里的ABC）
M-S-RET 插入同级TODO标签
S-up/down 调整优先级
任务细分  在标题的任何地方插入‘[/]’或者‘[%]’。当每个子任务的状态变化时，
或者当你在标记上按 C-c C-c时，这些标记状态也会随之更新。
*** 时间
输入C-c . 会出现一个日历
*** 导出
C-c C-e 选择相应的导出格式
*** 插入源代码
(org-babel-do-load-languages
 'org-babel-load-languages
 '(
   (sh . t)
   (python . t)
   (R . t)
   (ruby . t)
   (ditaa . t)
   (dot . t)
   (octave . t)
   (sqlite . t)
   (perl . t)
   (C . t)
   ))

#+BEGIN_SRC perl
print 1;

#+END_SRC

C-c C-c 对当前代码块求值
** 标题
#+TITLE: 神器中的神器org-mode之入门篇
** 字体
*粗体*
/斜体/
+删除线+
_下划线_
下标： H_2 O(这里必须留一个空格要不然2和O都成为小标，目前还不知道怎么去掉空格)
上标： E=mc^2
等宽字：  =git=
** 列表
无序列表以'-'、'+'或者'*'开头
有序列表以'1.'或者'1)'开头
描述列表用'::'
注意事项
列表符号后面都要有空格
同级别的列表缩进要相同
如果想要加入同级别的列表，可以 M-RET
空两行之后列表结束，如果空一行执行M-RET，实际上还是输入同级项
** 嵌入元数据
*** 内容元数据
org-mode中有以下几种

s    #+begin_src ... #+end_src
e    #+begin_example ... #+end_example  : 单行的例子以冒号开头
q    #+begin_quote ... #+end_quote      通常用于引用，与默认格式相比左右都会留出缩进
v    #+begin_verse ... #+end_verse      默认内容不换行，需要留出空行才能换行
c    #+begin_center ... #+end_center
l    #+begin_latex ... #+end_latex
L    #+latex:
h    #+begin_html ... #+end_html
H    #+html:
a    #+begin_ascii ... #+end_ascii
A    #+ascii:
i    #+index: line
I    #+include: line
代码
上面的单字母为快捷键字母，如输入一个<s 然后TAB后就变为：
#+begin_src

#+end_src
怎么样，这样是不是就很方便了。
上面的代码我们还可以加入一些参数，如

#+begin_src c -n -t -h 7 -w 40

#+end_src
其中：
c为所添加的语言
-n 显示行号
-t 清除格式
-h 7 设置高度为7 -w 40设置宽度为40
注释
以‘#‘开头的行被看作注释，不会被导出区块注释采用如下写法：
#+BEGIN_COMMENT
  块注释
  ...
 #+END_COMMENT
表格与图片
对于表格和图片，可以在前面增加标题和标签的说明，以方便交叉引用。比如在表格的前面添加：
#+CAPTION: This is the caption for the next table (or link)
则在需要的地方可以通过

\ref{table1}
来引用该表格。

嵌入html
对于导出html以及发布，嵌入html代码就很有用。比如下面的例子适用于格式化为cnblogs的代码块：
#+BEGIN_HTML
  <div class="cnblogs_Highlighter">
  <pre class="brush:cpp">
  int main()
  {
    return 0;
  }
  </pre>
  </div>
相当于在cnblogs的网页编辑器中插入"c++"代码。

包含文件
当导出文档时，你可以包含其他文件中的内容。比如，想包含你的“.emacs”文件，你可以用：
#+INCLUDE: "~/.emacs" src emacs-lisp
可选的第二个第三个参数是组织方式（例如，“quote”，“example”，或者“src”），如果是 “src”，语言用来格式化内容。组织方式是可选的，如果不给出，文本会被当作 Org 模式的正常处理。用 C-c ,可以访问包含的文件。

4.5.2 文档元数据
具体的内容可以到文档中查看：Export options 我们除了手动添加上面的元数据外，还可以用快捷键 C-c C-e t 插入选项，其中可能有些选项我们需要经常用到：

H:	标题层数
num:	章节(标题)是否自动编号
toc:	是否生成索引
creator:	是否生成 "creat by emacs…"
LINKUP:	UP: 链接
LINKHOME:	HEME: 链接
** 表格
org-mode里制作表格灰常灰常强大，其实我最初看了视频才开始动心学org-mode的。
*** 建立和操作表格
在 org mode 中，你可以画表格。方法很简单，在某一行顶格的位置输入’|'，然后输入表格第一行第一列的内容，再输入’|'，然后输入表格的的一行第二列的内容，以此类推。当第一行输入完成后，按 TAB， org mode 会把当前行对齐，然后为你创造出表格的下一行，让你继续输入。用 TAB 和 S+TAB可以在表格中正向或反向的移动。

比如下面的例子：
#+CAPTION: 表格的标题
| 1 | one |
| 2 | two |
| 3 | This is a long chunk of text |
| 4 | four |
有时候，表格的某一项特别的长，你可以在任意一个表格的空白项内输入数字来限制其所在列的长度。比如：
|   | <6>    |
| 1 | one    |
| 2 | two    |
| 3 | This=> |
| 4 | four   |
在上面的例子中，第二列的长度不会超过6，超过的部分会被隐藏起来。你可以把鼠标移动到’This=>’上面，会有浮动标签显示出该项的内容，或者输入’C-c `’可以编辑被隐藏的内容。如果你发现表格的某一项没有如你预期的那样被隐藏起来，你可以在表格中的任意位置按 ‘C-c C-c’。

我们还可以把表格弄的更好看一些。在表格的某两行之间加入’|-’，然后按TAB，可以作出下面的效果：
|   | <6>    |
|---+--------|
| 1 | one    |
| 2 | two    |
| 3 | This=> |
| 4 | four   |
*** 快捷键
整体区域
操作	说明
C-c 竖线	创建或者转化成表格
C-c C-c	调整表格，不移动光标
TAB	移动到下一区域，必要时新建一行
S-TAB	移动到上一区域
RET	移动到下一行，必要时新建一行
编辑行和列
快捷键	说明
M-LEFT/RIGHT	移动列
M-UP/DOWN	移动行
M-S-LEFT/RIGHT	删除/插入列
M-S-UP/DOWN	删除/插入行
C-c -	添加水平分割线
C-c RET	添加水平分割线并跳到下一行
C-c ^	根据当前列排序，可以选择排序方式
*** 表格中的计算
例如一张价格表：

数量	单价	总额
2	3.45
4	4.34
5	3.44
5	5.6
在第二行第三列中输入'=$1*$2′。$1和$2表示第一列和第二列，在你自己的表格中，你会使用你希望的列数进行计算。
| 数量 | 单价 |  总额 |
|------+------+-------|
|    2 | 3.45 |   6.9 |
|    4 | 4.34 | 17.36 |
|    5 | 3.44 |  17.2 |
|    5 |  5.6 |   28. |
#+TBLFM: $3=$1*$2
你可以输入’C-u C-c C-c’强制org mode为整个表格进行计算。如果你不想让某一列都按照公式计算，只希望在某一特定项上进行计算，你可以这样输入：':=$1*$2′, 即在等号前再加一个冒号。

** 连接
在一个链接上按C-c C-o即可访问，至于调用什么程序访问，取决于链接的内容，emacs和org mode的配置了。
*** 自动连接
对于符合链接规则的内容，org-mode会自动将其视为链接，包括括文件、网页、邮箱、新闻组、BBDB 数据库项、 IRC 会话和记录等。下面是一些例子：

http://www.astro.uva.nl/~dominik            on the web
file:/home/dominik/images/jupiter.jpg       file, absolute path
/home/dominik/images/jupiter.jpg            same as above
file:papers/last.pdf                        file, relative path
file:projects.org                           another Org file
docview:papers/last.pdf::NNN                open file in doc-view mode at page NNN
id:B7423F4D-2E8A-471B-8810-C40F074717E9     Link to heading by ID
news:comp.emacs                             Usenet link
mailto:adent@galaxy.net                     Mail link
vm:folder                                   VM folder link
vm:folder#id                                VM message link
wl:folder#id                                WANDERLUST message link
mhe:folder#id                               MH-E message link
rmail:folder#id                             RMAIL message link
gnus:group#id                               Gnus article link
bbdb:R.*Stallman                            BBDB link (with regexp)
irc:/irc.com/#emacs/bob                     IRC link
info:org:External%20links                   Info node link (with encoded space)
对于文件链接，可以用::后面增加定位符的方式链接到文件的特定位置。定位符可以是行号或搜索选项。如：

file:~/code/main.c::255                     进入到 255 行
file:~/xx.org::My Target                    找到目标‘<<My Target>>’
file:~/xx.org/::#my-custom-id               查找自定义 id 的项
*** 手动连接
[[link][description ] ]
[[link]] [[link ] ]
*** 内部连接
内部链接就类似于HTML的锚点（实际上export成HTML文件后就变成了锚点），可以实现在一个文档内部的跳转。如下命令定义了一个名为target的跳转目标：

#<<target>> (这里我把锚点设置到*连接*这一部分开始处，大家可以点击下面效果中两个连接试试效果)
如下方式可以设置到target的链接：
[[]] 或 [[target][猛击锚点] ]

*** 其他常用的连接命令
C-c l 可以在光标所在处创建一个跳转目标点，在需要跳转至该目标的位置输入命令C-c C-l可以建立到目标的链接当输入C-c C-l命令，光标若处在已经存在的一个链接上的时候，可以编辑改链接。命令C-c %可以记录当前光标所在位置，当光标移到其他地方后，可以用C-c &跳转回来。这里的位置记录类似一个 kill-ring，重复输入C-c %可以记录多个位置，重复输入C-c &可以连续跳转到之前记录的对应位置上。

** 注脚
在 org mode 中，你可以为你的文章添加注脚（footnote）。注脚的格式有两种，一是方括号+数字，二是方括号+fn+名字。比如下面有两个例子：在 org mode 的正文中写下这两句话：

The Org homepage1 now looks a lot better than it used to. The Org homepage2 now looks a lot better than it used to.

插入脚注：C-c C-x f 接下俩你可以写一些其他东西，然后在文章的末尾写上下面两句话（注意：必须要顶格写）：

[1] The link is: http://orgmode.org
[fn:orghome] The link is: http://orgmode.org
把光标移动到正文的1处，按 C-c C-c，可以跳转到注脚1处，在注脚1处按 C-c C-c，可以跳转到正文的1 处。

** 分割线
五条短线或以上显示为分隔线。

-----
** 标签tag
对于信息的管理，有分类(category)和标签(tag)两种方式。这两种方式各有特点：

通常分类是固定的，很少变化，而tag随时可以增加。 分类通常表现为树状结构，比较清晰，但是树状结构过于简单，不能表达复杂的信息。比如，如果有多个分类树，处理起来就会比较麻烦。

所以，这两种方式通常结合起来使用。比如blog系统中，通常既支持文章的分类（树），又支持为每篇文章作tag标记。

org-mode作为最好的文档编辑利器 ，在支持文内大纲（也是树状结构）的同时，还方便的支持tag功能。tag可以在多篇文档中共用。

简单的说：分类就如同我博客分为c++、emacs、linux等一些列类别，但是我的每篇博文都会根据不同的内容设置 不同的标签。

*** 标记tags
如果希望文档中的所有标题都具有某些标签，只需要定义文档元数据：

#+FILETAGS: :Peter:Boss:Secret:
更方便的做法是在正文部分用C-c C-q 或直接在标题上用C-c C-c创建标签，这种方式可以

*** 预定义tags
上面提到，除了可以输入标签外，还可以从预定义的标签中进行选择。如果手工输入标签，在标题后设置标签，键入:后，M-Tab自动提供标签的补齐。预定义的方式有两种：

-1. 在当前文件头部定义这种方式预定义的标签只能在当前文件中使用。使用#+TAGS元数据进行标记，如：

#+TAGS: { 桌面(d) 服务器(s) }  编辑器(e) 浏览器(f) 多媒体(m) 压缩(z)
每项之间必须用空格分隔，可以在括号中定义一个快捷键；花括号里的为标签组，只能选择一个

对标签定义进行修改后，要在标签定义的位置按 C-c C-c 刷新才能生效。

-2. 在配置文件中定义 上面的标签定义只能在当前文件生效，如果要在所有的.org 文件中生效，需要在 Emacs 配置文件 .emacs 中进行定义：

(setq org-tag-alist '((:startgroup . nil)
                      ("@work . ?w) ("@home" . ?h)
                      ("@tennisclub" . ?t)
                      (:endgroup . nil)
                      ("laptop" . ?l) ("pc" . ?p)))
默认情况下，org会动态维护一个Tag列表，即当前输入的标签若不在列表中，则自动加入列表以供下次补齐使用。

为了使这几种情况（默认列表、文件预设tags，全局预设tags）同时生效，需要在文件中增加一个空的TAGS定义：

#+TAGS:

*** tags查询
设置标签的主要目的还是为了查询。org-mode 会为搜索结果建立一个视图

快捷键	说明
C-c \	可以用来查找某个tag下的所有项目
C-c / m	搜索并按树状结构显示
C-c a m	从所有agenda file里建立符合某tag的全局性列表
+   和      a+b   同时有这两个标签
-   排除    a-b   有 a 但没有 b
|   或      a|b   有 a 或者有 b
&   和      a&b   同时有 a 和 b，可以用“+”替代
在查询视图中 C-c C-c 退出(我用怎么不管用呢？)

** 格式导出与发布
*** 导出
org-mode可以导出很多种格式 ,其中最常用的就是文本、网页和pdf格式的。

C-c C-e a 导出为文本文件。 C-c C-e h 导出为 HTML 文件

pdf有点麻烦需要什么latex，目前还不会。

*** 发布
发布相关的命令：

命令	说明
C-c C-e C	提示指明一个项目，将所有的文件发布
C-c C-e P	发布包含当前文件的项目
C-c C-e F	只发布当前文件
C-c C-e E	发布所有项目
* git
** 命令
1.创建一个新的repository：
先在github上创建并写好相关名字，描述。
$cd ~/hello-world        //到hello-world目录,本地目录名与repository的名字不一定相同
$git init                    //初始化
$git remote add origin git@github.com:WadeLeng/hello-world.git        //增加到remote
$git push origin master    //push到github上
3.更新项目（没新加文件，只有删除或者修改文件）：
$cd ~/hello-world
$git commit -a          //记录删除或修改了哪些文件
$git push origin master  //提交到github
4.忽略一些文件，比如*.o等:
$cd ~/hello-world
$vim .gitignore    //把文件类型加入到.gitignore中，保存
然后就可以git add . 能自动过滤这种文件
5.clone代码到本地：
$git clone git@github.com:WadeLeng/hello-world.git
假如本地已经存在了代码，而仓库里有更新，把更改的合并到本地的项目：
$git fetch origin    //获取远程更新
$git merge origin/master //把更新的内容合并到本地分支
6.撤销
$git reset
7.删除
$git rm  * // 不是用rm

如果我们往一个非空的目录下 clone git 项目，就会提示错误信息：

fatal: destination path '.' already exists and is not an empty directory.

解决的办法是：
1. 进入非空目录，假设是 /workdir/proj1
2. git clone --no-checkout https://git.oschina.net/NextApp/platform.git tmp
3. mv tmp/.git .   #将 tmp 目录下的 .git 目录移到当前目录
4. rmdir tmp
5. git reset --hard HEAD
然后就可以进行各种正常操作了。
** cygwin+git配置
*** 参考文档
https://help.github.com/articles/generating-an-ssh-key/
http://www.cnblogs.com/EasonWu/archive/2012/11/27/git-windows-setup-by-cygwin.html
install openssh
http://www.howtogeek.com/howto/41560/how-to-get-ssh-command-line-access-to-windows-7-using-cygwin/
*** cygwin初始化
Devel\git
Devel\git-svn(TODO)
Net\openssh
Net\openssl(TODO)
*** Generating a new SSH key
1. Paste the text below, substituting in your GitHub email address.

$ssh-keygen -t rsa -b 4096 -C "your_email@example.com"
# Creates a new ssh key, using the provided email as a label
Generating public/private rsa key pair.

2. When you're prompted to "Enter a file in which to save the key," press Enter. This accepts the default file location.

Enter a file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter]

3. At the prompt, type a secure passphrase. For more information, see "Working with SSH key passphrases".

Enter passphrase (empty for no passphrase): [Type a passphrase]
Enter same passphrase again: [Type passphrase again]
(设置passphrase为空，否则emacs shell无法使用)
*** Adding your SSH key to the ssh-agent
1. Ensure ssh-agent is enabled:

# start the ssh-agent in the background
$eval "$(ssh-agent -s)"
Agent pid 59566

2. Add your SSH key to the ssh-agent. If you used an existing SSH key rather than generating a new SSH key, 
you'll need to replace id_rsa in the command with the name of your existing private key file.

$ssh-add ~/.ssh/id_rsa
*** Add the SSH key to your GitHub account.
1. Copy the SSH key to your clipboard.
$ sudo apt-get install xclip
# Downloads and installs xclip. If you don't have `apt-get`, you might need to use another installer (like `yum`)

$ xclip -sel clip < ~/.ssh/id_rsa.pub
# Copies the contents of the id_rsa.pub file to your clipboard

2. In the top right corner of any page, click your profile photo, then click Settings.
3. In the user settings sidebar, click SSH and GPG keys.
4. Click New SSH key.
5. Paste your key into the "Key" field.
6. Click Add SSH key.
7. Confirm the action by entering your GitHub password.

*** 个人配置
1. 解决Git命令输出中文文件名的显示问题
git config --system core.quotepath false
2. Git命令输出中开启颜色显示
git config --system color.ui true
3. 配置username和email
git config --global user.name "Jim"
git config --global user.email Jim@gmail.com
4. 通过命令来查看Git设置
git config -l

地址:D:\cygwin64\etc\gitconfig

[core]
	quotepath = false
[color]
	ui = true
[alias]
	ci = commit -m
	ps = push origin master
	pl = pull origin master

* emacs
** 配置
https://github.com/purcell/emacs.d
*** yasnippet 0.7.0和auto-complete-mode一起使用
1 If you follow `normal install` way, setup is simple
See its official documentation.
Install the yasnippet into somewhere and add following code into your .emacs:
(add-to-list 'load-path
              "~/.emacs.d/plugins/yasnippet-x.y.z")
(require 'yasnippet) ;; not yasnippet-bundle
(yas/initialize)
(yas/load-directory "~/.emacs.d/plugins/yasnippet-x.y.z/snippets")
2 If you use elpa package system, setup is even simpler
After installation, you only need two lines in .emacs.
(require 'yasnippet)
(yas/initialize)
Yasnippet 0.7.0 have already defined two locations for the snippets, "~/.emacs.d/yasnippet-install-path/yasnippet-x.y.z/snippets" and "~/.emacs.d/snippets". Yasnippet will load snippets in BOTH directories at startup.
So you only put your own snippets in "~/.emacs.d/snippets" and done. No need to tweak .emacs at all. To verify my claim, you can `C-h v yas/snippet-dirs' to check value of "yas/snippet-dirs". Please note "yas/root-directory" is the alias of "yas/snippet-dirs".
3 The real world setup is NOT simple
I will explain the reasons at first and give my complete yasnippet configuration code at the end of the this post.
3.1 Two snippets may share the same key, so I need activate `yas/dropdown-prompt'
One issue is I need a user-friendly dropdown window popped up when the key I input has several candidates. For example, when I type "inc" in C code. There are two candicates `#include "…"' and `#include <…>' available. A handy dropdown popup will help me to choose one of them as efficient as possible.
The good news is such fancy popup is a standard component of yasnippet. It's called `yas/dropdown-prompt'. Yasnippet's default algorithm will activate it at highest prority.
The bad news is for some wierd reason yasnippet won't load that dropdown-list by default. So you need manually load that component by one line of elisp code `(require 'dropdown-list)'.
3.2 `yas/dropdown-prompt' is not perfect
I cannot scroll down the dropdown window when there are more candidates it can display. That's especially annoying when calling `yas/insert-snippet'. In this case, we need use `yas/completing-prompt' instead. I will show the fix at the end of this article.
3.3 Yasnippets conflicts with other plugins
I use Auto Complete Mode (version 20120327 in elpa). There are two issuses when using it with yasnippets.
First, it use TAB key to do the auto-complete thing while yasnippet also uses TAB key. So I need re-configure hotkeys of yasnippets.
Second, yansippet changed its API `yas/get-snippet-tables' since version 0.7.0. This make the auto-complete cannot use yasnippet at all. This issue is reported and fixed by tkf. Actually all you need do is simple:
cd auto-complete-install-dir
rm auto-complete-config.elc
curl -L https://raw.github.com/tkf/auto-complete/337caa2ccc254a79f615bb2417f0d2fb9552b547/auto-complete-config.el > auto-complete-config.el
4 My final yasnippet setup
(require 'yasnippet)
(yas/initialize)
;; default TAB key is occupied by auto-complete
(global-set-key (kbd "C-c ; u") 'yas/expand)
;; default hotkey `C-c & C-s` is still valid
(global-set-key (kbd "C-c ; s") 'yas/insert-snippet)
;; give yas/dropdown-prompt in yas/prompt-functions a chance
(require 'dropdown-list)
;; use yas/completing-prompt when ONLY when `M-x yas/insert-snippet'
;; thanks to capitaomorte for providing the trick.
(defadvice yas/insert-snippet (around use-completing-prompt activate)
     "Use `yas/completing-prompt' for `yas/prompt-functions' but only here..."
       (let ((yas/prompt-functions '(yas/completing-prompt)))
       ad-do-it))
*** 显示图片
GnuWin32是souceforge.net上一个将GNU的工具porting到Windows的项目
http://gnuwin32.sourceforge.net/packages.html
需要相应的dll文件 libpng14-14.dll，jpeg62.dll，libtiff3.dll，libgiflib4.dll 。
M-x org-display-inline-images
*** 图片宽度问题
1.设为t代表使用原图片大小 (setq org-image-actual-width t)
2.设为某个固定值，任何图片都会变成设定的值 (setq org-image-actual-width 300)       ; Set width to 300
3.设定为Number List，则org-mode会先寻找 #+ATTR.*的设定，否则用使用设定的宽度
(setq org-image-actual-width '(300))       ; Fallback to width 300
#+CAPTION: 设定图片的宽度为100
#+ATTR_HTML: :width 100
[[file]]
4.设定为nil
当有 #+ATTR.* 时使用自己的设定 (setq org-image-actual-width nil)
*** 配置git-emacs
教程：http://alexott.net/en/writings/emacs-vcs/EmacsGit.html#fn.1
下载地址：https://github.com/tsgates/git-emacs/tree/master
安装cygwin-git

快捷键：
git-status:C-x g s
git-commit-all:C-x g c RET
提交代码:C-c C-c
*** 配置helm
C-l
出错时package-list-package
*** Ac-Js2
无法跳转时Call run-skewer and open up a Javascript file


foo.bar.baz();

placing the cursor on `foo', `bar' or `baz' and executing M-. will
take you straight to their respective definitions. Use M-, to jump
back to where you were.
*** 配置helm-gtags
1.安装 gtags.el。
将emacsUtil中的Global/bin加入环境变量
2.生成代码索引文件。
在需要查看源代码的文件夹中运行gtags -vw 会产生GTAGS,GRTAGS,GSYMS三个文件
*** emacs cygwin
http://www.khngai.com/emacs/cygwin.php
** 备忘
*** helm用法
使用说明 http://tuhdo.github.io/helm-intro.html
C-x c i   helm-semantic-or-imenu  find the major definitions,
C-x C-f   C-j to narrow to the highlighting candidate. C-l to go back.
          After you go up with C-l, you can go back the exact visited directories with C-r.

C-x c m   helm-man-woman  quickly jump to any man entry using Helm interface, 
C-x c s   helm-surfraw   provides a fast UNIX command line interface to a variety of popular WWW search engines
helm-google-suggest  (global-set-key (kbd "C-c h g") 'helm-google-suggest)

helm-info-*
<prefix> h g	Command: helm-info-gnus
<prefix> h i	Command: helm-info-at-point
<prefix> h r	Command: helm-info-emacs
helm-info-gdb.
helm-info-find.
helm-info-elisp.


M-x	helm-M-x	List commands
M-y	helm-show-kill-ring	Shows the content of the kill ring
C-x b	helm-mini	Shows open buffers, recently opened files
C-x C-f	helm-find-files	The helm version for find-file
C-s	helm-ff-run-grep	Run grep from within helm-find-files
C-c C-v	helm-semantic-or-imenu	Helm interface to semantic/imenu
C-c h m	helm-man-woman	Jump to any man entry
C-c h /	helm-find	Helm interface to find
C-c h l	helm-locate	Helm interface to locate
C-c h o	helm-occur	Similar to occur
C-c h a	helm-apropos	Describes commands, functions, variables, …
C-c h h g	helm-info-gnus	 
C-c h h i	helm-info-at-point	 
C-c h h r	helm-info-emacs	 
C-c h <tab>	helm-lisp-completion-at-point	Provides a list of available functions
C-c h b	helm-resume	Resumes a previous helm session
C-h SPC	helm-all-mark-rings	Views content of local and global mark rings
C-c h r	helm-regex	Visualizes regex matches
C-c h x	helm-register	Shows content of registers
C-c h t	helm-top	Helm interface to top
C-c h s	helm-surfraw	Command line interface to many web search engines
C-c h g	helm-google-suggest	Interactively enter search terms and get results from Google in helm buffer
C-c h c	helm-color	Lists all available faces
C-c h M-:	helm-eval-expression-with-eldoc	Get instant results for emacs lisp expressions in the helm buffer
C-c h C-,	helm-calcul-expression	Helm interface to calc
C-c C-l	helm-eshell-history	Interface to eshell history
C-c C-l	helm-comint-input-ring	Interface to shell history
C-c C-l	helm-mini-buffer-history	Interface to mini-buffer history

*** helm-gtags
helm-gtags-dwim (M-.)

Find name by context.

Jump to header file if cursor is on include statement
Jump to tag definition if cursor is on tag reference
Jump to tag reference if cursor is on tag definition


方法定义     (define-key helm-gtags-mode-map (kbd "M-t") 'helm-gtags-find-tag)  
方法使用     (define-key helm-gtags-mode-map (kbd "M-r") 'helm-gtags-find-rtag)
查找变量     (define-key helm-gtags-mode-map (kbd "M-s") 'helm-gtags-find-symbol)
显示方法     (define-key helm-gtags-mode-map (kbd "M-g M-p") 'helm-gtags-parse-file)
     (define-key helm-gtags-mode-map (kbd "C-c <") 'helm-gtags-previous-history)
     (define-key helm-gtags-mode-map (kbd "C-c >") 'helm-gtags-next-history)
     (define-key helm-gtags-mode-map (kbd "M-,") 'helm-gtags-pop-stack)))
*** web-mode
snippet insertion C-c C-s (auto indented, aware of text selection, engine specific)
jumping C-c C-n between opening / closing HTML tags 
code folding C-c C-f for HTML elements and control blocks
clever selection and expansion C-c C-m
suspicious whitespaces detection C-c C-w
*** surfraw安装 make安装
**** 官方文档
http://surfraw.alioth.debian.org/#installation
lynx 为默认浏览器
**** /usr/lib/surfraw/baidu
#!/bin/sh
# $Id$
# elvis: baidu                -- Search the web using Baidu (www.baidu.com)
. surfraw || exit 1

w3_config_hook () {
    def   SURFRAW_baidu_results "$SURFRAW_results"
    def   SURFRAW_baidu_search search
    defyn SURFRAW_baidu_lucky 0
    def   SURFRAW_baidu_country zh
    def   SURFRAW_baidu_safe default
}

w3_usage_hook () {
    cat <<EOF
Usage: $w3_argv0 [options] [search words]...
Description:
  Surfraw search the web using Google (www.baidu.com)
Local options:
  -results=NUM                  Number of search results returned
                                Default: $SURFRAW_baidu_results
                                Environment: SURFRAW_baidu_results
  -search=                      Specialized search on topic
          image       |       Images
          v           |       Videos
          map         |       Maps
          tieba       |       Tieba
          news                |       News
          zhidao        |       Zhidao
          music         |       Music
          wenku         |       Wenku
  -i, -images                   Image Search (same as -search=image)
  -v, -videos                   Video Search (same as -search=v)
  -m, -maps                     Map Search (same as -search=map)
  -n, -news                     News Search (same as -search=news)
  -w, -wenku                    Wenku Search (same as -search=wenku)
  -t, -tieba                    Tieba Search (same as -search=tieba)
  -z, -zhidao                   Zhidao Search (same as -search=zhidao)
  -M, -mu, -music               Music Search (same as -search=music)
EOF
    w3_global_usage
}

w3_parse_option_hook () {
    opt="$1"
    optarg="$2"
    case "$opt" in
    -r*=*)      setopt   SURFRAW_baidu_results "$optarg" ;;
    -sa*=*)     setopt   SURFRAW_baidu_safe    "$optarg" ;;
    -s*=*)      setopt   SURFRAW_baidu_search  "$optarg" ;;
    -w*)        setopt   SURFRAW_baidu_search  wenku     ;;
    -tb|-tieba)        setopt   SURFRAW_baidu_search  tieba     ;;
    -z*)        setopt   SURFRAW_baidu_search  zhidao    ;;
    -i*)        setopt   SURFRAW_baidu_search  image     ;;
    -v*)        setopt   SURFRAW_baidu_search  v         ;;
    -m|-map)        setopt   SURFRAW_baidu_search  map       ;;
    -ns|-news)   setopt   SURFRAW_baidu_search  news      ;;
    -M|-mu|-music) setopt   SURFRAW_baidu_search  music  ;;
    *) return 1 ;;
    esac
    return 0
}

w3_config
w3_parse_args "$@"
# w3_args now contains a list of arguments

safe=""
case "$SURFRAW_baidu_safe" in
  strict)   safe="&safe=strict"   ;;
  moderate) safe="&safe=moderate" ;;
  off)      safe="&safe=off"      ;;
esac

url="http://"

if test -z "$w3_args" ; then
    case "$SURFRAW_baidu_search" in
        i*) url="${url}image"  ;;
        m*) url="${url}map"    ;;
        b*) url="${url}baike"  ;;
        n*) url="${url}news"   ;;
        v*) url="${url}v"      ;;
        *)  url="${url}www"    ;;
    esac
    url="${url}.baidu.com"
else
    search="$SURFRAW_baidu_search"
    case "$SURFRAW_baidu_search" in
        t*) url="${url}tieba"; search="f" ;;
        w*) url="${url}wenku"; search="search" ;;
        z*) url="${url}zhidao"; search="search" ;;
        map) url="${url}map"; search="m" ;;
        v*) url="${url}v"; search="v" ;;
        i*) url="${url}image" ; search="i";;
        music) url="${url}music"   ; search="search"    ;;
        n*) url="${url}news"   ; search="ns"    ;;
        *)  url="${url}www"    ; search="s"     ;;
    esac

    url="${url}.baidu.com/${search}"
    escaped_args=`w3_url_of_arg $w3_args`
    url="${url}?&ie=utf-8&word=${escaped_args}&wd=${escaped_args}&rn=${SURFRAW_baidu_results}"
    url="${url}${safe}${extra}"
fi
echo $url
w3_browse_url "$url"

** 光标 编辑
C-X C-q	只读
C-c C-o	打开/关闭方法
C-h v      查看变量
C-M-h      选中整个函数
c-x h       全选
C-l        :光标移到屏幕中间
M-<        :光标移到文档首
M->        :光标移到文档末
C-u n cmd,M-n    :执行cmd n次
C-d        :删除光标下的字符
M-d        :删除光标后的单词
C-k        :剪切光标至行末
M-k        :剪切光标至句末
C-@        :make a mark
C-x u,C-/,C-_    :undo
C-x C-v        :打开文件并替换掉当前buffer中的文件
C-x i        :插入文件
C-←        :pervious word
C-→        :next word
C-↑        :backward-paragraph
C-↓        :forward-paragraph
C-v        :page down
M-v        :page up
C-p        :previous line
C-n        :next line
C-f        :forward char
C-b        :backward char
M-f        :forward word
M-b        :backward word
M-a        :backward sentence
M-e        :forward sentence
C-M-@, C-M-SPC     :mark up
F10        :打开菜单
M-g g           :跳到指定的行
M-x d        :打开文件目录
ESC ESC ESC    :关闭mini-buffer
SHIFT+方向键    :选取文本
** 搜索
C-s input    :向前搜索
C-s         :搜索下一个
C-r input    :反向搜索
C-s C-w        :搜索光标所在位置的字
C-s C-s        :重复上次搜索
C-r C-r        :重复上次反向搜索
C-r 在进入查找/替换模式后，该命令进入迭代编辑模式
C-M-x 退出迭代编辑模式，返回到查找/替换模式
C-M-s 向前正则搜索
C-M-r 向后正则搜索
C-M-% 正则交互替换
** 缓冲区
C-x C-f        :打开或创建文件
C-x C-b        :显示buffer列表，可以用方向键选择
C-x C-w        :另存为
C-x b        :switch-to-buffer
C-x k        :kill buffer
C-x C-s        :save buffer
C-x C-c        :save buffer and kill terminal
C-x ←        :pervious buffer
C-x →        :next buffe
** Emacs帮助
C-h ?        :得到关于帮助的完整列表
M-x apropos  :想做一件事情，但是不知道如何去做。可以用上面的命令，然后关键字甚至是正则表达式， Emacs就会搜索帮助中一切相关的信息。会得到一个列表，每一项都有超链接和简要的说明。
C-h k        :快捷键对应的命令。
C-h f        :查询函数信息；
C-h v        : 查询变量信息；
C-h m        :可以得到当前所有mode的一个总体说明。
C-h b        :查看当前buffer所有可用的快捷键
C-h t        :打开学习向导
C-h w        :查看某命令对应的快捷键
<快捷键序列> C-h    :查看当前buffer中以<快捷键序列>开头的所有快捷键列表。例如想看所有以C-x开头的快捷键就输入C-x C-h就可以了。
find-function    :查看Emacs函数的代码。M-x find-function。
find-variable    :查看变量的代码。
describe-face    :查看face的文档
find-face-definition    :查看face的代码
** 基本快捷键(Basic)
    C-x C-w 使用其他文件名另存为文件
    C-x C-v 关闭当前缓冲区文件并打开新文件
    C-x i 在当前光标处插入文件
    M-x revert-buffer RETURN (照着这个输入)撤销上次存盘后所有改动
    M-x recover-file RETURN 从自动存盘文件恢复
    M-x recover-session RETURN 如果你编辑了几个文件, 用这个恢复
** 光标移动基本快捷键(Basic Movement)
    C-f 后一个字符
    C-b 前一个字符
    C-p 上一行
    C-n 下一行
    M-f 后一个单词
    M-b 前一个单词
    C-v 向下翻一页
    M-v 向上翻一页
    M-< 到文件开头
    M-> 到文件末尾
** 编辑(Editint)
    C-M-\ 对选定区域进行缩进
    M-n 重复执行后一个命令n次
    C-u 重复执行后一个命令4次
    C-u n 重复执行后一个命令n次
    C-d 删除(delete)后一个字符
    M-d 删除后一个单词
    Del 删除前一个字符
    M-Del 删除前一个单词
    C-k 移除(kill)一行
    C-w 移除标记
    C-Space 设置开始标记 (例如标记区域)
    C-@ 功能同上, 用于C-Space被操作系统拦截的情况
    M-y 召回更早的内容 (在kill缓冲区内循环)
    C-x C-x 交换光标和标记
    C-t 交换两个字符的位置
    M-t 交换两个单词的位置
    C-x C-t 交换两行的位置
    M-u 使从光标位置到单词结尾处的字母变成大写
    M-l 与M-u相反
    M-c 使从光标位置开始的单词的首字母变为大写

** 在线帮助(Online-Help)
    C-h c 显示快捷键绑定的命令
    C-h k 显示快捷键绑定的命令和它的作用
    C-h l 显示最后100个键入的内容
    C-h w 显示命令被绑定到哪些快捷键上
    C-h f 显示函数的功能
    C-h v 显示变量的含义和值
    C-h b 显示当前缓冲区所有可用的快捷键
    C-h t 打开emacs教程
    C-h i 打开info阅读器
    C-h C-f 显示emacs FAQ
    C-h p 显示本机Elisp包的信息

** 搜索/替换(Seach/Replace)
    C-r 向前搜索
    C-g 回到搜索开始前的位置(如果你仍然在搜索模式中)
    M-% 询问并替换(query replace)
    Space或y 替换当前匹配
    Del或n 不要替换当前匹配
    . 仅仅替换当前匹配并退出(替换)
    , 替换并暂停(按Space或y继续)
    ! 替换以下所有匹配
    ^ 回到上一个匹配位置
    RETURN或q 退出替换

** 使用正则表达式(Regular expression)搜索/替换
    可在正则表达式中使用的符号:
    ^ 行首
    $ 行尾
    . 单个字符
    .* 任意多个(包括没有)字符
    \< 单词开头
    \> 单词结尾
    [] 括号中的任意一个字符(例如[a-z]表示所有的小写字母)

    M C-s RETURN 使用正则表达式向后搜索
    M C-r RETURN 使用正则表达式向前搜索
    C-s 增量搜索
    C-s 重复增量搜索
    C-r 向前增量搜索
    C-r 重复向前增量搜索
    M-x query-replace-regexp 使用正则表达式搜索并替换

** 窗口命令(Window Commands)
    C-x 0 关闭窗格
    C-x ^ 扩大窗格
    M-x shrink-window 缩小窗格
    M C-v 滚动其他窗格内容
    C-x 4 f 在其他窗格中打开文件
    C-x 4 0 关闭当前缓冲区和窗格
    C-x 5 2 新建窗口(frame)
    C-x 5 f 在新窗口中打开文件
    C-x 5 o 切换至其他窗口
    C-x 5 0 关闭当前窗口
** 书签命令(Bookmark commands)
    C-x r m 在光标当前位置创建书签
    C-x r b 转到书签
    M-x bookmark-rename 重命名书签
    M-x bookmark-delete 删除书签
    M-x bookmark-save 保存书签
    C-x r l 列出书签清单

    d 标记等待删除
    Del 取消删除标记
    x 删除被标记的书签
    r 重命名
    s 保存列表内所有书签
    f 转到当前书签指向的位置
    m 标记在多窗口中打开
    v 显示被标记的书签(或者光标当前位置的书签)
    t 切换是否显示路径列表
    w 显示当前文件路径
    q 退出书签列表

    M-x bookmark-write 将所有书签导出至指定文件
    M-x bookmark-load 从指定文件导入书签

** Shell
    C-c C-c 类似unix里的C-c(停止正在运行的程序)
    C-d 删除光标后一个字符
    C-c C-d 发送EOF
    C-c C-z 挂起程序(unix下的C-z)
    M-p 显示前一条命令
    M-n 显示后一条命令
** DIRectory EDitor (dired)
    C-x d 打开dired
    C(大写C) 复制
    d 标记等待删除
    D 立即删除
    e或f 打开文件或目录
    g 刷新当前目录
    G 改变文件所属组(chgrp)
    k 从屏幕上的列表里删除一行(不是真的删除)
    m 用*标记
    n 光标移动到下一行
    o 在另一个窗格打开文件并移动光标
    C-o 在另一个窗格打开文件但不移动光标
    P 打印文件
    q 退出dired
    Q 在标记的文件中替换
    R 重命名文件
    u 移除标记
    v 显示文件内容
    x 删除有D标记的文件
    Z 压缩/解压缩文件
    M-Del 移除标记(默认为所有类型的标记)
    ~ 标记备份文件(文件名有~的文件)等待删除
    # 标记自动保存文件(文件名形如#name#)等待删除
    */ 用*标记所有文件夹(用C-u */n移除标记)
    = 将当前文件和标记文件(使用C-@标记而不是dired的m标记)比较
    M-= 将当前文件和它的备份比较
    ! 对当前文件应用shell命令
    M-} 移动光标至下一个用*或D标记的文件
    M-{ 移动光标至上一个用*或D标记的文件
    % d 使用正则表达式标记文件等待删除
    % m 使用正则表达式标记文件为*
    + 新建文件夹
    > 移动光标至后一个文件夹
    < 移动光标至前一个文件夹
    s 切换排序模式(按文件名/日期)

    或许把这个命令归入这一类也很合适:
    M-x speedbar 打开一个独立的目录显示窗口

** Telnet
    M-x telnet 打开telnet模式
    C-d 删除后一个字符或发送EOF
    C-c C-c 停止正在运行的程序(和unix下的C-c类似)
    C-c C-d 发送EOF
    C-c C-o 清除最后一个命令的输出
    C-c C-z 挂起正在运行的命令
    C-c C-u 移除前一行
    M-p 显示前一条命令

** Text
    只能在text模式里使用
    M-s 使当前行居中
    M-S 使当前段落居中
    M-x center-region 使被选中的区域居中

** 宏命令(Macro-commands)
    C-x ( 开始定义宏
    C-x ) 结束定义宏
    C-x e 运行最近定义的宏
    M-n C-x e 运行最近定义的宏n次
    M-x name-last-kbd-macro 给最近定义的宏命名(用来保存)
    M-x insert-kbd-macro 将已命名的宏保存到文件
    M-x load-file 载入宏

** 编程(Programming)
    M C-\ 自动缩进光标和标记间的区域
    M-m 移动光标到行首第一个(非空格)字符
    M-^ 将当前行接到上一行末尾处
    M-; 添加缩进并格式化的注释
    M-a 移动光标到声明的开始处
    M-e 移动光标到声明的结尾处
    M C-a 移动光标到函数的开始处
    M C-e 移动光标到函数的结尾处
    C-c RETURN 将光标移动到函数的开始处并标记到结尾处
    C-c C-q 根据缩进风格缩进整个函数
    C-c C-a 切换自动换行功能
    C-c C-d 一次性删除光标后的一串空格(greedy delete)

    为了实现下面的一些技术, 你需要在保存源代码的目录里运行"etags
    *.c *.h *.cpp"(或者源代码的其他的扩展名)
    M-.(点) 搜索标签
    M-x tags-search ENTER 在所有标签里搜索(使用正则表达式)
    M-,(逗号) 在tags-search里跳至下一个匹配处
    M-x tags-query-replace 在设置过标签的所有文件里替换文本

** GDB(调试器)
    M-x gdb 在另一个的窗格中打开gdb

** 版本控制(Version Control)
    C-x v d 显示当前目录下所有注册过的文件(show all registered files in this dir)
    C-x v = 比较不同版本间的差异(show diff between versions)
    C-x v u 移除上次提交之后的更改(remove all changes since last checkin)
    C-x v ~ 在不同窗格中显示某个版本(show certain version in different window)
    C-x v l 打印日志(print log)
    C-x v i 标记文件等待添加版本控制(mark file for version control add)
    C-x v h 给文件添加版本控制文件头(insert version control header into file)
    C-x v r 获取命名过的快照(check out named snapshot)
    C-x v s 创建命名的快照(create named snapshot)
    C-x v a 创建gnu风格的更改日志(create changelog file in gnu-style)
* emacs Lisp(C-h i)
** basic
*** 简单教程
;; ELisp中的赋值函数是是setq，下面的表达式给变量my-name赋值"Bastien"
(setq my-name "Bastien")
;; ^ 把光标停在这里，再键入C-x C-e

;; 下面insert函数的作用是在光标所在出插入字符Hello
(insert "Hello!")
;; ^ 把光标停在这里，再键入C-x C-e

;; insert函数还可以两个常量字符，比如
(insert "Hello" " world!")

;; insert函数还可以接受变量作为参数，我们之前已经给my-name变量赋过值了
;; 所以下面命令的输出结果是 "Hello, I am Bastien"
(insert "Hello, I am " my-name)

;; defun命令用来定义一个函数,语法是
;; (defun 函数名 (参数列表) (函数体))
(defun hello () (insert "Hello, I am " my-name))
;; ^ 把光标停在这里，再键入C-x C-e 执行defun命令来定义函数
;; 通过defun命令，你已经在Emacs中安装了这个hello函数，这个函数就成为了Emacs的一部分，知道你退出Emacs或者改变hello的定义

;; 从下面开始，我们将不再提醒读者使用C-x C-e来定义函数和执行ELisp指令

;; 在Elisp中直接输入函数的名称就是调用该函数。
;; 下面的命令的输入结果是: Hello, I am Bastien
(hello)

;; 前面定义的hello函数不接受任何参数,过于简单，
;; 现在我们重新定义hello函数，让它接受一个参数name。 
(defun hello (name) (insert "Hello " name))

;; 然后调用新的hello函数，并且提供一个参数。
;; 下面命令的输出结果是"Hello you"
(hello "you")

== progn,let和交互式函数== 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; 执行switch-to-buffer-other-window命令，将在在一个新的窗口中打开一个buffer
;; 该buffer命名叫做 test, 并且把光标移到新的buffer的窗口中。
(switch-to-buffer-other-window "*test*")

;; 要回到原来的buffer中，可以使用鼠标点击原来的buffer
;; 或者使用组合键 C-x o 
;; C-x o的意思是: 先按下Ctrl-x 再按下o

;; 如果要执行一系列的指令，可以使用流程函数progn，把函数命令连接起来.
;; 下面的命令,先打开一个新的buffer,再执行hello函数，该hello函数的参数是"you"
(progn
(switch-to-buffer-other-window "*test*")
(hello "you"))

;; 如果要清空一个buffer,可以调用erase-buffer函数。下面的命令先清空test buffer,再调用hello函数做打印
(progn
(switch-to-buffer-other-window "*test*")
(erase-buffer)
(hello "there"))

;; 在这一系列的质量后面再添加调用一个other-window函数，这样在hello函数被调用完毕之后
;; 光标自动回到之前的buffer窗口中
(progn
(switch-to-buffer-other-window "*test*")
(erase-buffer)
(hello "you")
(other-window 1))

;; let函数用来做局部变量的定义 下面的一系列命令中
;; let函数首先定义local-name变量的值为“you”
;; 然后接着执行括号中其它的语句块部分，这个功能和progn类似
(let ((local-name "you"))
(switch-to-buffer-other-window "*test*")
(erase-buffer)
(hello local-name)
(other-window 1))

;; format函数可以用做格式化的输出 其中%s表示该s的地方将被之后提供的一个字符串,即visitor替换
;; \n表示换行
(format "Hello %s!\n" "visitor")

;; 现在我们利用format函数来改进之前定义的hello函数
(defun hello (name)
(insert (format "Hello %s!\n" name)))

;; 执行这个函数结果是"Hello you"，并且光标换到下一行
(hello "you")

;; 下面我们再设计一个greeting函数，该函数接受一个参数name,
;; 在函数体的内部又使用了let函数，给一个局部变量your-name赋值
;; 最后把参数和局部变量格式化的打印出来
(defun greeting (name)
(let ((your-name "Bastien"))
(insert (format "Hello %s!\n\nI am %s."
name 
your-name ; 局部变量
))))

;; 执行greeting函数，并提供"you"字符串作为参数
(greeting "you")

;; read-from-minibuffer函数提供和用户交互的功能，这个函数可以帮助Elisp程序从用户处得到输入
(read-from-minibuffer "Enter your name: ")

;; 比如如果我们希望greeting函数能够从用户处得到姓名，并且做打印格式化的欢迎信息。
;; 可以先调用read-from-minibuffer在minibuffer中提示用户输入姓名，
;; 然后把得到的结果赋给局部变量your-name，
;; 最后insert函数在当前buffer中插入格式化的输出
(defun greeting (from-name)
(let ((your-name (read-from-minibuffer "Enter your name: ")))
(insert (format "Hello!\n\nI am %s and you are %s."
from-name ; 格式化输出参数1
your-name ; 格式化输出参数2
))))

;; 执行这个函数
(greeting "Bastien")

;; 再稍加改进greeting 把结果打印在新的buffer中
(defun greeting (from-name)
(let ((your-name (read-from-minibuffer "Enter your name: ")))
(switch-to-buffer-other-window "*test*")
(erase-buffer)
(insert (format "Hello %s!\n\nI am %s." your-name from-name))
(other-window 1)))

;; 执行这个函数
(greeting "Bastien")

== 列表和综合实例 ==

;; Lisp中使用括号构造列表，使用setq给变量赋值。
;; 下面的命令先构造一个列表，再把这个列表赋给list-of-names变量
(setq list-of-names '("Sarah" "Chloe" "Mathilde"))
;; ^这里的单引号表示这是一个列表

;; 如果想要得到列表中的第一个元素，可以使用car函数
(car list-of-names)

;; 如果想要得到列表中的除第一个元素以外的其它元素，可以使用cdr函数
(cdr list-of-names)

;; 以后push函数可以在列表的头部插入新的元素，所以下面的命令将改变list-of-name中元素的个数
(push "Stephanie" list-of-names)

;; mapcar函数对列表中的把列表中的每一个元素分别取出来，赋给hello函数
(mapcar 'hello list-of-names)

;; 重新定义greeting函数，在一个新的，清空的buffer中，对list-of-names列表中的每一个元素，调用hello函数
;; 调用完毕之后，再让光标回到原的buffer中
(defun greeting ()
(switch-to-buffer-other-window "*test*")
(erase-buffer)
(mapcar 'hello list-of-names)
(other-window 1))

;;执行这个函数，我们将得到一个名叫test的buffer，其中的内容是
;; Hello Stephanie!
;; Hello Sarah!
;; Hello Chloe!
;; Hello Mathilde!
;; 暂时先不要关闭这个buffer!后面还有用！ 
(greeting)

;; 下面我们对buffer做一些更有意思的事情！
;; 定义一个replace-hello-by-bonjour函数，顾名思义，就是把hello替换成bonjour
;; 该函数首先把光标移到一个叫做test的buffer中
;; 再把光标移到该buffer的开头
;; 从头开始搜索字符串Hello,并且替换成Bonjour
;; 结束之后在把光标移会到一开始的buffer中。
(defun replace-hello-by-bonjour ()
(switch-to-buffer-other-window "*test*")
(goto-char (point-min)) ;该函数把光标移到buffer的开头
(while (search-forward "Hello")
(replace-match "Bonjour"))
(other-window 1))

;; 其中 (search-forward "Hello") 在当前的buffer中做前向搜索
;; (while x y) 当x 的条件满足时执行y指令 ，当x返回nil时，while循环结束

;; 执行这个函数 替换test buffer中的hello
(replace-hello-by-bonjour)

;; test buffer中的结果如下
;; Bonjour Stephanie!
;; Bonjour Sarah!
;; Bonjour Chloe!
;; Bonjour Mathilde!

;; 在minibuff中，还会有一条错误信息 "Search failed: Hello".
;; 把(search-forward "Hello")一句换成如下就不会有错误信息了
;; (search-forward "Hello" nil t)

;; 其中 nil参数表示 搜索的区域不加限制，直到buffer结束
;; 其中t参数指示search-foward函数 跳过错误信息 直接退出

;; 新hello-to-bonjour如下：
(defun hello-to-bonjour ()
(switch-to-buffer-other-window "*test*")
(erase-buffer)
;; 对list-of-names列表中的每个元素 使用hello函数
(mapcar 'hello list-of-names)
(goto-char (point-min))
;; 搜索Hello替换成Bonjour
(while (search-forward "Hello" nil t)
(replace-match "Bonjour"))
(other-window 1))

;; 执行这个函数
(hello-to-bonjour)

;; 下面的boldify-names 函数 ，
;; 首先把光标挪到名叫test的buffer的开头，
;; 然后使用regular expression 搜索 “Bonjour + 其它任何内容” 的pattern，
;; 然后对找到的字符加粗。 
(defun boldify-names ()
(switch-to-buffer-other-window "*test*")
(goto-char (point-min))
(while (re-search-forward "Bonjour \<span class='MathJax_Preview'>\(.+\\)</span><script type='math/tex'>.+\</script>!" nil t)
(add-text-properties (match-beginning 1) ;返回匹配模式中，最先匹配的位置
(match-end 1) ;返回最后匹配的位置
(list 'face 'bold)))
(other-window 1))

;; 执行这个函数 
(boldify-names)

== 帮助和参考==

;; 在Emacs中我们可以通过如下的方式得到变量和函数的帮助信息
;; C-h v a-variable RET
;; C-h f a-function RET
;;
;; 下面的命令将打开整个Emacs Manual
;;
;; C-h i m elisp RET
*** 列表处理
**** 列表
lisp列表求值 '(+ 2 4)
**** 赋值
(set 'flowers '(rose vio))
(setq flowers '(rose vio))
(setq flowers '(rose)
              '(vio rose))
*** 编写函数
**** defun函数
(defun function-name (arguments..)
  "optional-documnetation.."
  (interactive argument-passing-info);optional
  body..)

一个函数定义在defun之后最多有五个部分
1. 符号名
2. 参数列表，可以为()
3. 描述这个函数的文档（可选）
4. 一个使函数成为交互函数的表达式（可选），可以通过键入M-x和函数名来使用，或者键入一个适当的键
5. 指导计算机如何运行代码，函数主体
**** let函数
let创建局部变量
(let varlist body...)

(let ((VARIABLE VALUE)
      (VARIABLE VALUE)
      ...)
      BODY...)

If you do not bind the variables in a `let' statement to specific
initial values, they will automatically be bound to an initial value of
`nil', as in the following expression:

**** if函数
     (if (> 5 4)                             ; if-part
         (message "5 is greater than 4!"))   ; then-part

       (if (equal characteristic 'fierce)
           (message "It's a tiger!")))

**** else
     (if (> 4 5)                               ; if-part
         (message "4 falsely greater than 5!") ; then-part
       (message "4 is not greater than 5!"))   ; else-part
**** Lisp中的真和假
nil 表示空列表或假
**** save-excursion函数
位点就是光标所在的当前位置（字符前）
可以使用C-x C-x使光标从位点跳到标记处
*** 基本函数：car,cdr,cons,length,nthcdr,setcar,setcdr,while
car 返回列表的第一个元素      (car '(rose violet daisy buttercup))
cdr 返回列表的其余部分（第一个元素除外）
     (car '((lion tiger cheetah)
            (gazelle antelope zebra)
            (whale dolphin seal)))

cons 插入元素
(cons 'pine '(fir oak maple))
After evaluating this list, you will see
(pine fir oak maple)

length 计算元素个数
(length '(daisy buttercup))
=> 2

nthcdr重复使用cdr
(nthcdr 2 '(pine fir oak maple))
 => (oak maple)

setcar  Changing the first element of a list.
(setcar animals 'hippopotamus)

setcdr  Changing the rest of a list.
(setcdr domesticated-animals '(cat dog))

while循环
(while list
  (print (car list))
  (setq list (cdr list))))

  SET-COUNT-TO-INITIAL-VALUE
    (while (< count desired-number)         ; true-or-false-test
    BODY...
    (setq count (1+ count)))              ; incrementer

*** 配置.emacs
(add-hook 'text-mode-hook 'turn-on-auto-fill)
add-hook将turn-on-auto-fill加到变量text-mode-hook之后

(setq mail-aliases t)
the line says, in effect, "Yes, use mail aliases."

(setq-default indent-tabs-mode nil)
The `setq-default' command sets values only in buffers 
that do not have their own local values for the variable.

*Keybindings*
;;; Compare windows
(global-set-key "\C-cw" 'compare-windows)

Here is how to unbind a key, so it does not work:

;;; Unbind `C-x f'
(global-unset-key "\C-xf")

Rarely used functions are frequently autoloaded.
(autoload 'html-helper-mode
  "html-helper-mode" "Edit HTML documents" t)
*** How to Define Keys;
http://ergoemacs.org/emacs/keyboard_shortcuts.html
* Linux
** 安装
*** 安装chrome
wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb
sudo apt-get -f install
dpkg -i google-chrome-stable_current_amd64.deb
*** 安装emacs
$ sudo add-apt-repository ppa:cassou/emacs
$ sudo apt-get update
$ sudo apt-get install emacs24
*** 安装Surfaw
sudo apt-get install surfraw
http://surfraw.alioth.debian.org/
surfraw ERROR: couldn't find global config in /usr/local/etc/xdg/surfraw/conf or $XDG_CONFIG_DIRS
cp -r /usr/local/etc/xdg/surfraw/ /etc/xdg/

在.bashrc中设置别名
alias b='sr baidu'
source ~/.bashrc立刻生效

百度脚本
#!/bin/sh
# $Id$
# elvis: baidu                -- Search the web using Baidu (www.baidu.com)
. surfraw || exit 1

w3_config_hook () {
    def   SURFRAW_baidu_results "$SURFRAW_results"
    def   SURFRAW_baidu_search search
    defyn SURFRAW_baidu_lucky 0
    def   SURFRAW_baidu_country zh
    def   SURFRAW_baidu_safe default
}

w3_usage_hook () {
    cat <<EOF
Usage: $w3_argv0 [options] [search words]...
Description:
  Surfraw search the web using Google (www.baidu.com)
Local options:
  -results=NUM                  Number of search results returned
                                Default: $SURFRAW_baidu_results
                                Environment: SURFRAW_baidu_results
  -search=                      Specialized search on topic
          image       |       Images
          v           |       Videos
          map         |       Maps
          tieba       |       Tieba
          news                |       News
          zhidao        |       Zhidao
          music         |       Music
          wenku         |       Wenku
  -i, -images                   Image Search (same as -search=image)
  -v, -videos                   Video Search (same as -search=v)
  -m, -maps                     Map Search (same as -search=map)
  -n, -news                     News Search (same as -search=news)
  -w, -wenku                    Wenku Search (same as -search=wenku)
  -t, -tieba                    Tieba Search (same as -search=tieba)
  -z, -zhidao                   Zhidao Search (same as -search=zhidao)
  -M, -mu, -music               Music Search (same as -search=music)
EOF
    w3_global_usage
}

w3_parse_option_hook () {
    opt="$1"
    optarg="$2"
    case "$opt" in
    -r*=*)      setopt   SURFRAW_baidu_results "$optarg" ;;
    -sa*=*)     setopt   SURFRAW_baidu_safe    "$optarg" ;;
    -s*=*)      setopt   SURFRAW_baidu_search  "$optarg" ;;
    -w*)        setopt   SURFRAW_baidu_search  wenku     ;;
    -tb|-tieba)        setopt   SURFRAW_baidu_search  tieba     ;;
    -z*)        setopt   SURFRAW_baidu_search  zhidao    ;;
    -i*)        setopt   SURFRAW_baidu_search  image     ;;
    -v*)        setopt   SURFRAW_baidu_search  v         ;;
    -m|-map)        setopt   SURFRAW_baidu_search  map       ;;
    -ns|-news)   setopt   SURFRAW_baidu_search  news      ;;
    -M|-mu|-music) setopt   SURFRAW_baidu_search  music  ;;
    *) return 1 ;;
    esac
    return 0
}

w3_config
w3_parse_args "$@"
# w3_args now contains a list of arguments

safe=""
case "$SURFRAW_baidu_safe" in
  strict)   safe="&safe=strict"   ;;
  moderate) safe="&safe=moderate" ;;
  off)      safe="&safe=off"      ;;
esac

url="http://"

if test -z "$w3_args" ; then
    case "$SURFRAW_baidu_search" in
        i*) url="${url}image"  ;;
        m*) url="${url}map"    ;;
        b*) url="${url}baike"  ;;
        n*) url="${url}news"   ;;
        v*) url="${url}v"      ;;
        *)  url="${url}www"    ;;
    esac
    url="${url}.baidu.com"
else
    search="$SURFRAW_baidu_search"
    case "$SURFRAW_baidu_search" in
        t*) url="${url}tieba"; search="f" ;;
        w*) url="${url}wenku"; search="search" ;;
        z*) url="${url}zhidao"; search="search" ;;
        map) url="${url}map"; search="m" ;;
        v*) url="${url}v"; search="v" ;;
        i*) url="${url}image" ; search="i";;
        music) url="${url}music"   ; search="search"    ;;
        n*) url="${url}news"   ; search="ns"    ;;
        *)  url="${url}www"    ; search="s"     ;;
    esac

    url="${url}.baidu.com/${search}"
    escaped_args=`w3_url_of_arg $w3_args`
    url="${url}?&ie=utf-8&word=${escaped_args}&wd=${escaped_args}&rn=${SURFRAW_baidu_results}"
    url="${url}${safe}${extra}"
fi
echo $url
w3_browse_url "$url"
*** 安装percol
https://github.com/mooz/percol#whats-this
先安装python setuptools
git clone git://github.com/mooz/percol.git
sudo python setup.py install

配置.percol.d/rc.py
*** 安装python setuptools
wget --no-check-certificate https://bootstrap.pypa.io/ez_setup.py
sudo python ez_setup.py --insecure
** 命令
*** 修改文件属性
sudo chmod a+w filename

*** 解压-压缩
1 *.tar 用 tar –xvf 解压 
2 *.gz 用 gzip -d或者gunzip 解压 
3 *.tar.gz和*.tgz 用 tar –xzf 解压 
4 *.bz2 用 bzip2 -d或者用bunzip2 解压 
5 *.tar.bz2用tar –xjf 解压 
6 *.Z 用 uncompress 解压 
7 *.tar.Z 用tar –xZf 解压 
8 *.rar 用 unrar e解压 
9 *.zip 用 unzip 解压
*** 拷贝
$ sudo apt-get install xclip
# Downloads and installs xclip. If you don't have `apt-get`, you might need to use another installer (like `yum`)

$ xclip -sel clip < ~/.ssh/id_rsa.pub
# Copies the contents of the id_rsa.pub file to your clipboard
* book
** Refactoring
*** Bad Smells in Code
*Duplicated Code（重复代码）*
*Long Method（过长函数）*
*Large Class（过大的类）*
*Long Parameter List（过长参数列）*
Use _Replace Parameter with Method_ when you can get the data in one parameter by making
a request of an object you already know about. This object might be a field or it might be another
parameter. Use _Preserve Whole Object_ to take a bunch of data gleaned from an object and
replace it with the object itself. If you have several data items with no logical object, use
_Introduce Parameter Object_.
*Divergent Change（发散式变化）* （一个类受多种变化的影响）
use _Extract Class_ to put them all together
*Shotgun Surgery（霰弹式修改）* （一个变化引发多个类相应修改）
use _Move Method_ and _Move Field_ to put all the changes into a single class
use _Inline Class_ to bring a whole bunch of behavior together
*Feature Envy（依恋情结）*
 a method that seems more interested in a class other than the one it actually is in
 use _Move Method_ to get it wants to be elsewhere
 use _Extract Method_ on the jealous bit and _Move Method_ to give it a dream home
*Data Clumps（数据泥团）*
*Primitive Obsession（基本类型偏执）*
*Switch Statements（switch语句）*
*Parallel Inheritance Hierarchies（平行继承体系）*
*Lazy Class（冗赘）*
*Speculative Generality（夸夸其谈未来性）*
*Temporary Field（临时字段）*
*Message Chains（过度耦合消息链）*
*Middle Man（中间人）*
*Inappropriate Intimacy（狎昵关系）*
*Alternative Classes with Different Interfaces（接口不同的等效类）*
*Incomplete Library Class（不完美的库类）*
*Data Class（数据元素类）*
*Refused Bequest（拒绝继承）*
*Comments（过多注释）*
*** Composing Methods（重新组织函数）
**** Extract Method（提炼函数）
You have a code fragment that can be grouped together.
Turn the fragment into a method whose name explains the purpose of the method.

#+BEGIN_SRC java
void printOwing(double previousAmount) {
    Enumeration e = _orders.elements();
    double outstanding = previousAmount * 1.2;
    printBanner();
    // calculate outstanding
    while (e.hasMoreElements()) {
        Order each = (Order) e.nextElement();
        outstanding += each.getAmount();
    }
    printDetails(outstanding);
}

//提炼函数后
void printOwing(double previousAmount) {
    double outstanding = previousAmount * 1.2;
    printBanner();
    outstanding = getOutstanding(outstanding);
    printDetails(outstanding);
}
double getOutstanding(double initialValue) {
    double result = initialValue;
    Enumeration e = _orders.elements();
    while (e.hasMoreElements()) {
        Order each = (Order) e.nextElement();
        result += each.getAmount();
    }
    return result;
}

#+END_SRC

**** Inline Method（内联函数）
A method's body is just as clear as its name.
Put the method's body into the body of its callers and remove the method.

**** Inline Temp（内联临时变量）
You have a temp that is assigned to once with a simple expression, and the temp is getting in the
way of other refactorings.
Replace all references to that temp with the expression.
#+BEGIN_SRC java
 double basePrice = anOrder.basePrice();
 return (basePrice > 1000)

=>
 return (anOrder.basePrice() > 1000)

#+END_SRC

**** Replace Temp with Query(以查询代替临时变量)
You are using a temporary variable to hold the result of an expression.
Extract the expression into a method. Replace all references to the temp with the expression. The
new method can then be used in other methods.
#+BEGIN_SRC java
double getPrice() {
 int basePrice = _quantity * _itemPrice;
 double discountFactor;
 if (basePrice > 1000) discountFactor = 0.95;
 else discountFactor = 0.98;
 return basePrice * discountFactor;
}

//提炼后的函数
double getPrice() {
  return basePrice() * discountFactor();
}

private double discountFactor() {
  if ( basePrice() > 1000) return 0.95;
  else return 0.98;
}
private int basePrice() {
  return _quantity * _itemPrice;
}

#+END_SRC
**** Introduce Explaining Variable(引入解释型变量)
You have a complicated expression.
Put the result of the expression, or parts of the expression, in a temporary variable with a name
that explains the purpose.

#+BEGIN_SRC java
double price() {
 // price is base price - quantity discount + shipping
 return _quantity * _itemPrice -
 Math.max(0, _quantity - 500) * _itemPrice * 0.05 +
 Math.min(_quantity * _itemPrice * 0.1, 100.0);
}

=>
double price() {
 final double basePrice = _quantity * _itemPrice;
 final double quantityDiscount = Math.max(0, _quantity - 500) * _itemPrice * 0.05;
 final double shipping = Math.min(basePrice * 0.1, 100.0);
 return basePrice - quantityDiscount + shipping;
}

//Example with Extract Method
double price() {
 return basePrice() - quantityDiscount() + shipping();
 }
 private double quantityDiscount() {
 return Math.max(0, _quantity - 500) * _itemPrice * 0.05;
 }
  private double shipping() {
 return Math.min(basePrice() * 0.1, 100.0);
 }
 private double basePrice() {
 return _quantity * _itemPrice;
}

#+END_SRC

So when do I use Introduce Explaining Variable?
The answer is when Extract Method is more effort.
**** Split Temporary Variable(分解临时变量)
You have a temporary variable assigned to more than once, but is not a loop variable nor a
collecting temporary variable.
Make a separate temporary variable for each assignment.

#+BEGIN_EXAMPLE java
double temp = 2 * (_height + _width);
System.out.println (temp);
temp = _height * _width;
System.out.println (temp);

=>
final double perimeter = 2 * (_height + _width);
System.out.println (perimeter);
final double area = _height * _width;
System.out.println (area);

#+END_EXAMPLE

**** Remove Assignments to Parameters(移除对参数的赋值)
The code assigns to a parameter.
Use a temporary variable instead.

#+BEGIN_EXAMPLE java
int discount (int inputVal, int quantity, int yearToDate) {
if (inputVal > 50) inputVal -= 2;

=>
int discount (int inputVal, int quantity, int yearToDate) {
int result = inputVal;
if (inputVal > 50) result -= 2;

#+END_EXAMPLE
**** TODO Replace Method with Method Object(以函数对象取代函数)
You have a long method that uses local variables in such a way that you cannot apply Extract
Method.
Turn the method into its own object so that all the local variables become fields on that object.
You can then decompose the method into other methods on the same object.

*Mechanics*
・ Create a new class, name it after the method.
・ Give the new class a final field for the object that hosted the original method (the source
object) and a field for each temporary variable and each parameter in the method.
・ Give the new class a constructor that takes the source object and each parameter.
・ Give the new class a method named "compute."
・ Copy the body of the original method into compute. Use the source object field for any
invocations of methods on the original object.
・ Compile.
・ Replace the old method with one that creates the new object and calls compute.

#+BEGIN_EXAMPLE java
Class Account{
    int gamma (int inputVal, int quantity, int yearToDate) {
        int importantValue1 = (inputVal * quantity) + delta();
        int importantValue2 = (inputVal * yearToDate) + 100;
        if ((yearToDate - importantValue1) > 100)
            importantValue2 -= 20;
        int importantValue3 = importantValue2 * 7;
        // and so on.
        return importantValue3 - 2 * importantValue1;
    }
}

class Gamma{
    private final Account _account;
    private int inputVal;
    private int quantity;
    private int yearToDate;
    private int importantValue1;
    private int importantValue2;
    private int importantValue3;

    Gamma (Account source, int inputValArg, int quantityArg, int yearToDateArg) {
        _account = source;
        inputVal = inputValArg;
        quantity = quantityArg;
        yearToDate = yearToDateArg;
    }

    //Now I can move the original method over. I need to modify any calls of features of account to use the _account field
    int compute () {
        importantValue1 = (inputVal * quantity) + _account.delta();
        importantValue2 = (inputVal * yearToDate) + 100;
        if ((yearToDate - importantValue1) > 100)
            importantValue2 -= 20;
        int importantValue3 = importantValue2 * 7;
        // and so on.
        return importantValue3 - 2 * importantValue1;
    }

}

//I then modify the old method to delegate to the method object:
int gamma (int inputVal, int quantity, int yearToDate) {
    return new Gamma(this, inputVal, quantity, yearToDate).compute();
}

//The benefit is that I can now easily use Extract Method on the
//compute method without ever worrying about the argument's passing:
int compute () {
    importantValue1 = (inputVal * quantity) + _account.delta();
    importantValue2 = (inputVal * yearToDate) + 100;
    importantThing();
    int importantValue3 = importantValue2 * 7;
    // and so on.
    return importantValue3 - 2 * importantValue1;
}
void importantThing() {
    if ((yearToDate - importantValue1) > 100)
        importantValue2 -= 20;
}


#+END_EXAMPLE
**** Substitute Algorithm（替换算法）
You want to replace an algorithm with one that is clearer.
Replace the body of the method with the new algorithm.
#+BEGIN_EXAMPLE java
String foundPerson(String[] people){
    for (int i = 0; i < people.length; i++) {
        if (people[i].equals ("Don")){
            return "Don";
        }
        if (people[i].equals ("John")){
            return "John";
        }
        if (people[i].equals ("Kent")){
            return "Kent";
        }
    }
    return "";
}

=>

String foundPerson(String[] people){
    List candidates = Arrays.asList(new String[] {"Don", "John", "Kent"});
    for (int i=0; i<people.length; i++)
        if (candidates.contains(people[i]))
            return people[i];
    return "";
}

#+END_EXAMPLE
*** Moving Features Between Objects（在对象之间搬移特性）
**** Move Method（搬移函数）
A method is, or will be, using or used by more features of another class than the class on which it is defined.

Create a new method with a similar body in the class it uses most. Either turn the old method into
a simple delegation, or remove it altogether.

**** Move Field（搬移方法）
A field is, or will be, used by another class more than the class on which it is defined.

Create a new field in the target class, and change all its users.
**** Extract Class（提炼类）
You have one class doing work that should be done by two.
Create a new class and move the relevant fields and methods from the old class into the new class.

**** Inline Class（将类内联化）
A class isn't doing very much.
Move all its features into another class and delete it.
**** Hide Delegate（隐藏委托关系）
A client is calling a delegate class of an object.
Create methods on the server to hide the delegate.

#+BEGIN_SRC java
class Person {
    Department _department;
    public Department getDepartment() {
        return _department;
    }
    public void setDepartment(Department arg) {
        _department = arg;
    }
}
class Department {
    private String _chargeCode;
    private Person _manager;
    public Department (Person manager) {
        _manager = manager;
    }
    public Person getManager() {
        return _manager;
    }
}


    //If a client wants to know a person's manager, it needs to get the department first:
    manager = john.getDepartment().getManager();

    // change all clients of person to use this new method:
    public Person getManager() {
        return _department.getManager();
    }
#+END_SRC

**** Remove Middle Man（移除中间人）
A class is doing too much simple delegation.
Get the client to call the delegate directly.
**** Introduce Foreign Method（引入外加函数）
A server class you are using needs an additional method, but you can't modify the class.
Create a method in the client class with an instance of the server class as its first argument.

#+BEGIN_SRC java
Date newStart = new Date (previousEnd.getYear(), previousEnd.getMonth(), previousEnd.getDate() + 1);

=>
Date newStart = nextDay(previousEnd);
private static Date nextDay(Date arg) {
  return new Date (arg.getYear(),arg.getMonth(), arg.getDate() + 1);
}
#+END_SRC

**** TODO Introduce Local Extension（引入本地扩展）
A server class you are using needs several additional methods, but you can't modify the class.
Create a new class that contains these extra methods. Make this extension class a subclass or a
wrapper of the original.

If you need one or two methods, you can use _Introduce Foreign Method_.
Once you get beyond a couple of these methods, however, they get out of hand. So you need to
group the methods together in a sensible place for them.

The first thing to decide is whether to use a subclass or a wrapper. Subclassing is the more obvious way:
Class mfDate extends Date {
 public nextDay()...
 public dayOfYear()...

A wrapper uses delegation:
class mfDate {
 private Date _original;

Example: Using a Subclass
#+BEGIN_SRC java
//First I create the new date as a subclass of the original:
class MfDateSub extends Date{
    public MfDateSub (String dateString) {
        super (dateString);
    };
    //Now I add a converting constructor, one that takes an original as an argument:
    public MfDateSub (Date arg) {
        super (arg.getTime());
    }
    Date nextDay() {
        return new Date (getYear(),getMonth(), getDate() + 1);
    }
}

#+END_SRC

Example: Using a Wrapper
#+BEGIN_SRC java
class mfDate {
    private Date _original;

    public MfDateWrap (String dateString) {
        _original = new Date(dateString);
    }
    public MfDateWrap (Date arg) {
        _original = arg;
    }

    public int getYear() {
        return _original.getYear();
    }
    public boolean equals (MfDateWrap arg) {
        return (toDate().equals(arg.toDate()));
    }
    Date nextDay() {
        return new Date (getYear(),getMonth(), getDate() + 1);
    }
}
#+END_SRC

*** Organizing Data（重新组织数据）
**** Self Encapsulate Field（自封装字段）
You are accessing a field directly, but the coupling to the field is becoming awkward.
Create getting and setting methods for the field and use only those to access the field.
#+BEGIN_SRC java
private int _low, _high;
  boolean includes (int arg) {
  return arg >= _low && arg <= _high;
}

=>
private int _low, _high;
boolean includes (int arg) {
  return arg >= getLow() && arg <= getHigh();
}
int getLow() {return _low;}
int getHigh() {return _high;}
#+END_SRC

**** Replace Data Value with Object(以对象取代数据值)
You have a data item that needs additional data or behavior.
Turn the data item into an object.
**** Change Value to Reference（将值对象改为引用对象）
You have a class with many equal instances that you want to replace with a single object.
Turn the object into a reference object.
*** Simplifying Conditional Expressions(简化条件表达式)
**** Decompose Conditional（条件分解表达式）
You have a complicated conditional (if-then-else) statement.
Extract methods from the condition, then part, and else parts.
#+BEGIN_SRC java
if (date.before (SUMMER_START) || date.after(SUMMER_END))
  charge = quantity * _winterRate + _winterServiceCharge;
else charge = quantity * _summerRate;

=>
if (notSummer(date))
  charge = winterCharge(quantity);
else charge = summerCharge (quantity);
#+END_SRC

**** Consolidate Duplicate Conditional Fragments(合并重复的条件片段)
The same fragment of code is in all branches of a conditional expression.
Move it outside of the expression.
#+BEGIN_SRC java
if (isSpecialDeal()) {
total = price * 0.95;
send();
}
else {
total = price * 0.98;
send();
}

=>
if (isSpecialDeal())
total = price * 0.95;
else
total = price * 0.98;
send();
#+END_SRC

**** Remove Control Flag（移除控制标志）
You have a variable that is acting as a control flag for a series of boolean expressions.
Use a *break* or *return* instead.
**** Replace Nested Conditional with Guard Clauses（以卫语句取代嵌套条件表达式）
A method has conditional behavior that does not make clear the normal path of execution.
Use guard clauses for all the special cases.

#+BEGIN_SRC java
double getPayAmount() {
    double result;
    if (_isDead) result = deadAmount();
    else {
        if (_isSeparated) result = separatedAmount();
        else {
            if (_isRetired) result = retiredAmount();
            else result = normalPayAmount();
        };
    }
    return result;
};

=>
double getPayAmount() {
    if (_isDead) return deadAmount();
    if (_isSeparated) return separatedAmount();
    if (_isRetired) return retiredAmount();
    return normalPayAmount();
};

Example: Reversing the Conditions

public double getAdjustedCapital() {
    double result = 0.0;
    if (_capital > 0.0) {
        if (_intRate > 0.0 && _duration > 0.0) {
            result = (_income / _duration) * ADJ_FACTOR;
        }
    }
    return result;
}

=>

public double getAdjustedCapital() {
    double result = 0.0;
    if (_capital <= 0.0) return result;
    if (_intRate > 0.0 && _duration > 0.0) {
        result = (_income / _duration) * ADJ_FACTOR;
    }
    return result;
}

=>
public double getAdjustedCapital() {
    double result = 0.0;
    if (_capital <= 0.0) return result;
    if (!(_intRate > 0.0 && _duration > 0.0)) return result;
    result = (_income / _duration) * ADJ_FACTOR;
    return result;
}

=>
public double getAdjustedCapital() {
    double result = 0.0;
    if (_capital <= 0.0) return result;
    205
        if (_intRate <= 0.0 || _duration <= 0.0) return result;
    result = (_income / _duration) * ADJ_FACTOR;
    return result;
}

=>
public double getAdjustedCapital() {
    if (_capital <= 0.0) return 0.0;
    if (_intRate <= 0.0 || _duration <= 0.0) return 0.0;
    return (_income / _duration) * ADJ_FACTOR;
}
#+END_SRC

* test case
** 新增页面初始化
1.输入框，图片是否初始化
2.错误提示是否清空（注意特殊错误提示）
** 输入框验证
1.是否定义最大长度
2.是否必填（$.trim()）
3.特殊字段是否做校验
4.ie9虚文字处理
** 翻页
1.页码必须是正整数
2.页码超过索引范围错误提示
3.翻页时不带搜索框条件
4.翻页后取消全选
** 保存
1.用户名等特殊字段唯一性校验
** 删除
1.删除最后一页时页面跳转到前一页
if(refund.defaultOption.sum%refund.defaultOption.count==1&&refund.defaultOption.pages>1){
        refund.defaultOption.pages--;
}
2.删除后是否需要删除相应数据
** 列表
1.按需排序
2.不显示删除的信息
** 页面显示
1.数据边长是否打乱样式
2.价格精确到两位小数
3.日期显示是否正确
** 点击事件
1.清空其他点击事件提示
** 上传图片
1.再次上传同一图片，防止图片未初始化(base64)
** 文字描述
1.提示语是否正确
2.页面文字描述是否正确
** 操作
1.操作的数据状态是否正确（如：已解散编队无需下架）
* useful
** xz压缩
xz -z 要压缩的文件
xz -d 要解压的文件
创建tar.xz文件：只要先 tar cvf xxx.tar xxx/ 这样创建xxx.tar文件先，然后使用 xz -z xxx.tar 来将 xxx.tar压缩成为 xxx.tar.xz
解压tar.xz文件：先 xz -d xxx.tar.xz 将 xxx.tar.xz解压成 xxx.tar 然后，再用 tar xvf xxx.tar来解包。
** 撩码的正确姿势

Window->Preferences->General->Editors->File Associations，
将.class和.class without source文件默认成通过JadClipse Class File Viewer打开。 

1、首先下载jar文件：net.sf.jadclipse_3.3.0.jar  
下载：https://sourceforge.net/projects/jadclipse/?source=typ_redirect
 
2、将jar文件net.sf.jadclipse_3.3.0.jar放在myEclipse的安装目录MyEclipse 10\dropins\plugins下
把jar包放完之后打开myEclipse，在Window-Preferences-Java中看是否有JadClipse这一项。
如果有，则直接进行第3步操作。。。
如果没有、那么请在MyEclipse安装目录下新建一个plugins文件夹，然后再把jar包移到plugins文件夹下。
注意：此时放的是MyEclipse 10\plugins文件夹下而不是MyEclipse 10\dropins\plugins文件夹下。。

3、下载反编译工具jad 
下载：http://varaneckas.com/jad/
 
4、压缩包文件解压，把可执行文件jad.exe解压到自己自定义的目录下，LZ把他放在了D盘下D:\jad.exe

5、打开MyEclipse。在Window-Preferences-Java-JadClipse中的Path to decompiler一项填充jad.exe的存放目录

** 高效使用搜索引擎
 "计算机视觉" filetype:ppt site:http://edu.cn
Url限定
intitle:"techrone” webpage的title中包含这个词
inurl:"techrone" url的字符串序列包含这个词
link:http://google.com 搜索结果中所有网页的内容都有这个链接地址
site:http://google.com 搜索结果限定在这个domain中
filetype:pdf, html, jpeg 限定搜索结果的文件类型
relatedto:techrone 给出这个单词的相关结果，可以是近义词

** 正确使用电脑的姿势
http://v.youku.com/v_show/id_XMjYzMzQ4MTM2.html

** 以管理员身份运行cmd
win+x+a
** emacs+
*** 安装
http://www.mulgasoft.com/emacsplus
http://marketplace.eclipse.org/content/emacs
1.Add the update site http://www.mulgasoft.com/emacsplus/e4/update-site to the Eclipse update manager (Help > Software Updates...) 
and install the desired features.  Select the Emacs+ Scheme as shown below to enable the Emacs+ key bindings
2.General-keys scheme apply
*** 快捷键
Split Window Horizontally (Ctrl-X 2)
Other Window (Ctrl-X O)
Make Frame (Ctrl-X 5 2)
Join Frame (Ctrl+X 5 0):
Recenter Top Bottom (Ctrl-L): Enhance Eclipse recenter to move current line to window center, top, and bottom, successively.
open file (C-x C-f)
C-v M-v
C-f, C-b, M-f, M-b, C-n, C-p, C-a, C-e, M-<, M->
M-w,C-y

*** 需要修改的快捷键
C-w ==> C-0  关闭窗口
C-z ==> C-/
C-/ ==> M-;
C-l ==> M-l 跳到指定的行
C-f ==> C-s
C-s unbind
C-y all unbind
C-v ==> C-y
C-k ==> M-k
*** eclipse快捷键
C-o 查看函数
C-m 窗口最大化
ctrl+shift+r：打开资源
alt+shift+r：重命名
Ctrl+Shift+X 把当前选中的文本全部变味小写
Ctrl+Shift+Y 把当前选中的文本全部变为小写

重构
Alt+Shift+R 重命名 (是我自己最爱用的一个了,尤其是变量和类的Rename,比手工方法能节省很多劳动力)
Alt+Shift+M 抽取方法 (这是重构里面最常用的方法之一了,尤其是对一大堆泥团代码有用)
Alt+Shift+C 修改函数结构(比较实用,有N个函数调用了这个方法,修改一次搞定)
Alt+Shift+L 抽取本地变量( 可以直接把一些魔法数字和字符串抽取成一个变量,尤其是多处调用的时候)
Alt+Shift+F 把Class中的local变量变为field变量 (比较实用的功能)
Alt+Shift+I 合并变量(可能这样说有点不妥Inline) 
Alt+Shift+V 移动函数和变量(不怎么常用) 
Alt+Shift+Z 重构的后悔药(Undo)
** 简历
简历模板 乔布简历http://cv.qiaobutang.com/
文件名 Java开发工程师_李壮_简历.pdf
常见名词  Java Linux HTML CSS JavaScript Eclipse MySQL jQuery Web
在线编辑简历 DeerCV
http://lzdev.deercv.com/admin
Markdown标记
# 菜单
- 列表
![] 图片
[] 链接

[password]
这里是我的手机、邮箱和微信等联系方式。
[/password]

Java简历模板
https://github.com/geekcompany/ResumeSample/blob/master/java.md

** 面试题
*** Java线程
Java线程面试题 Top 50 http://www.importnew.com/12773.html

*** 115个Java面试题和答案
http://www.importnew.com/10980.html
* url
** 命令行的艺术
https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md
** peco
下载地址 https://github.com/peco/peco/releases
来源 https://github.com/peco/peco
** percol
https://github.com/mooz/percol#whats-this
** choco(windows apt-get)
https://chocolatey.org/ 
** 高效 MacBook 工作环境配置
http://blog.jobbole.com/89013/
** 高效 Windows 工作环境 && Java 开发环境搭建
http://blog.jobbole.com/101710/
** 好用的工具
*** Clover给资源管理器加上类似Chrome的标签。
http://cn.ejie.me/
*** vimium 不用鼠标
* The Programmer Pragmatic
1. 关心你的技艺
2. 思考！你的工作
3. 提供各种选择，不要找蹩脚的借口（提供各种选择，而不是找借口，不要说事情做不到，说明能够做什么）
4. 不要容忍破窗户（当你看到糟糕的设计、代码时修正他们）
5. 做变化的催化剂（你不能强迫人们改变，相反，要向他们展示未来会怎样）
6. 记住大图景（不要太过注重细节，以致忘了查看你周围正在发生什么）
7. 使质量成为需求问题（让你的用户参与确定项目真正的质量需求）
8. 定期为你的知识资产投资，让学习成为习惯
9. 批判地分析你读到的和听到的
10. 你说什么和你怎么说同样重要（如果你不能有效的向别人传达你的想法，这些想法就毫无用处）
11. 不要重复自己
12. 让复用变得容易，创造一个支持复用的环境
13. 消除无关事物的影响（设计自足、独立、并具有单一良好的目的的组件）
14. 不存在最终决策
15. 用曳光弹找到目标
16. 为了学习而制作原型
17. 靠近问题领域编程
18. 估算，以避免意外发生
19. 通过代码对进度进行迭代
20. 用纯文本保存知识
21. 利用命令shell的力量
22. 要修正问题而不是指责
23. 不要假定，要证明
24. 编写能编写代码的代码，
* note
** info
txyuser:ubuntu password:LZgr,,1993 ip:115.159.204.96
alyuser:LZGRALY passwor:LZaly,,1993
googleuser:lizhuangDev password:lizhuang
GitHubuser:LZGH password:lizhuang111
163:lizhuang_dev@163.com password:lizhuang
** 每周浏览一次的网址
www.slashdot.org	linux新闻。影响开发者的问题的信息。
www.cetus-links.org	面向对象话题的数千链接
www.c2.com		Portland Pattern Repository和模式讨论 
* stretching
** 电脑使用者的拉伸
[[file:stretching\computer_user.png]]
** 久坐后的拉伸
[[file:stretching\sit_long.png]]
** 上网时的拉伸
[[file:stretching\a.png]]
** 肩背部拉伸小结
[[file:stretching\all.png]]
** 坐位拉伸小结
[[file:stretching\sit-all.png]]
** 43
[[file:stretching\43-1.png]]
[[file:stretching\43-1.png]]
** 44
[[file:stretching\44-1.png]]
[[file:stretching\44-1.png]]
** 45
[[file:stretching\45-1.png]]
[[file:stretching\45-1.png]]
** 46
[[file:stretching\46-1.png]]
[[file:stretching\46-1.png]]
** 47
[[file:stretching\47-1.png]]
[[file:stretching\47-1.png]]
** 89
:LOGBOOK:
:END:
[[file:stretching\89-1.png]]
[[file:stretching\89-1.png]]
* TODO company_task 
* TODO my_task
** TODO http://www.mulgasoft.com/emacsplus
** TODO percol zsh
* TODO next year task<2016-06-05 周日>[0/8]
** TODO [#A] write blog
** TODO [#A] read these books[0/9]
*** TODO [#A] 大话设计模式
*** TODO [#A] DesignPatterns
*** TODO [#A] Effective Java
*** TODO [#B] Thinking in Java
*** TODO [#B] Refactoring
*** TODO [#C] Code Complete
*** TODO [#C] 深入理解计算机系统
*** TODO [#C] tcp/ip详解 卷一、二、三
*** TODO [#C] 数据结构与算法
** TODO [#A] DesignPatterns
** TODO [#A] In-depth study java
** TODO [#A] read open source project
** TODO [#B] learn python
** TODO [#C] learn more about perl
** TODO [#C] learn something about architecture

